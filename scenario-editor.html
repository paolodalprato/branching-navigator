<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scenario Editor - ChoiceMap</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="shared-styles.css">
    <script src="shared-utils.js"></script>
    <style>
        /* Scenario Editor specific styles */
        .sidebar { width: 280px; transition: width 0.3s ease, opacity 0.3s ease; }
        .sidebar.collapsed { width: 0; overflow: hidden; opacity: 0; }
        .sidebar-toggle { position: absolute; left: 280px; top: 50%; transform: translateY(-50%); z-index: 100; background: #f97316; color: white; border: none; border-radius: 0 6px 6px 0; padding: 0.75rem 0.25rem; cursor: pointer; transition: left 0.3s ease; }
        .sidebar-toggle:hover { background: #ea580c; }
        .sidebar-toggle.collapsed { left: 0; }
        .node-list { flex: 1; overflow-y: auto; padding: 0.5rem; }
        .node-item { padding: 0.75rem; margin-bottom: 0.5rem; background: #ffffff; border-radius: 8px; cursor: pointer; border: 2px solid #e5e7eb; transition: all 0.2s; }
        .node-item:hover { border-color: #9ca3af; }
        .node-item.selected { border-color: #6366f1; background: #eef2ff; }
        .node-item.start-node { border-left: 3px solid #10b981; }
        .node-item.terminal { border-left: 3px solid #f59e0b; }
        .node-title { font-weight: 600; color: #111827; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .node-id-small { font-size: 0.7rem; color: #6b7280; font-family: monospace; margin-top: 0.15rem; }
        .node-badges { display: flex; gap: 0.25rem; margin-top: 0.5rem; flex-wrap: wrap; }
        .badge { font-size: 0.65rem; padding: 0.15rem 0.4rem; border-radius: 4px; background: #e5e7eb; color: #4b5563; }
        .badge-start { background: #d1fae5; color: #065f46; }
        .badge-terminal { background: #fef3c7; color: #92400e; }
        .main-editor { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .editor-header { padding: 1rem; background: #f9fafb; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center; }
        .lang-indicator { background: #e0e7ff; color: #4338ca; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.75rem; margin-left: 1rem; }
        .editor-content { flex: 1; overflow-y: auto; padding: 1.5rem; background: #ffffff; }
        .form-section { background: #f9fafb; border-radius: 8px; padding: 1.25rem; margin-bottom: 1.5rem; border: 1px solid #e5e7eb; }
        .form-section h3 { margin: 0 0 1rem 0; font-size: 1rem; color: #111827; display: flex; align-items: center; gap: 0.5rem; }
        .form-section .form-group { margin-bottom: 1rem; }
        .form-section .form-label { font-size: 0.8rem; margin-bottom: 0.4rem; }
        .form-section .form-input { padding: 0.6rem 0.75rem; font-size: 0.9rem; }
        .form-textarea { resize: none; min-height: 120px; }
        .textarea-container { position: relative; }
        .resize-handle { 
            width: 100%; 
            height: 24px; 
            background: #f97316; 
            border-radius: 0 0 6px 6px; 
            cursor: ns-resize; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            user-select: none;
        }
        .resize-handle:hover { background: #ea580c; }
        .resize-handle::before {
            content: '';
            width: 40px;
            height: 4px;
            background: rgba(255,255,255,0.6);
            border-radius: 2px;
        }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
        .form-row.single { grid-template-columns: 1fr; }
        .choice-item, .resource-item { background: #ffffff; border-radius: 6px; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #e5e7eb; transition: border-color 0.2s, box-shadow 0.2s; }
        .choice-header, .resource-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
        .choice-number { font-size: 0.8rem; color: #6366f1; font-weight: 600; }
        .form-section .form-select { padding: 0.6rem 0.75rem; font-size: 0.9rem; }
        .empty-state { text-align: center; padding: 3rem; color: #6b7280; }
        .empty-state h2 { color: #374151; margin-bottom: 0.5rem; }
        .map-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #ffffff; z-index: 200; display: flex; flex-direction: column; }
        .map-overlay-header { display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.5rem; border-bottom: 1px solid #e5e7eb; background: #f9fafb; }
        .map-overlay-header h2 { margin: 0; color: #111827; font-size: 1.25rem; }
        .map-legend { display: flex; gap: 1.5rem; font-size: 0.8rem; color: #6b7280; }
        .map-legend span { display: flex; align-items: center; gap: 0.4rem; }
        .legend-dot { width: 12px; height: 12px; border-radius: 3px; border: 2px solid; }
        .legend-start { border-color: #10b981; background: #065f46; }
        .legend-terminal { border-color: #f59e0b; background: #78350f; }
        .legend-selected { border-color: #818cf8; background: #3730a3; }
        .legend-orphan { border-color: #ef4444; background: #7f1d1d; }
        .legend-multiselect { border-color: #ec4899; background: #9d174d; }
        .map-overlay-content { flex: 1; overflow: auto; display: flex; align-items: center; justify-content: center; padding: 2rem; background: #f3f4f6; }
        .map-toolbar { display: flex; gap: 0.5rem; align-items: center; }
        .map-toolbar .btn { padding: 0.4rem 0.8rem; font-size: 0.8rem; }
        .map-toolbar .separator { width: 1px; height: 24px; background: #d1d5db; margin: 0 0.25rem; }
        .draggable-node { cursor: pointer; }
        .draggable-node.dragging { cursor: grabbing; opacity: 0.8; }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // ============================================================
        // DEFAULT DATA (loaded from defaults.json)
        // Module-level mutable: safe because React render is blocked by
        // layoutLoaded state until fetch completes. No race condition.
        // ============================================================
        let layoutConfig = {
            levelHeight: 120,
            nodeWidth: 140,
            nodeHeight: 44,
            padding: 60
        };

        const defaultTranslations = {
            step: 'Step',
            restart: 'Start Over',
            endOfPath: 'End of this path',
            resources: 'Resources',
            viewMap: 'View Map',
            mapOf: 'Map of',
            back: 'Back',
            download: 'Download',
            openLink: 'Open',
            watchVideo: 'Watch',
            mapAlignH: 'Align H',
            mapAlignV: 'Align V',
            mapDistribH: 'Distrib H',
            mapDistribV: 'Distrib V',
            mapSelectLevel: 'Select Level',
            mapAutoLayout: 'Auto Layout'
        };
        
        // ============================================================
        // SHARED UTILITIES (from shared-utils.js)
        // ============================================================
        const { calculateNodeLevels, getEffectiveLevel, getNodeLevel, calculateAutoPositions, ErrorBoundary, sanitizeUrl, sanitizeNodeId, getConnectionPath: sharedGetConnectionPath, getArrowPosition: sharedGetArrowPosition, getConnectionColor: sharedGetConnectionColor } = window.ChoiceMapUtils;

        // Wrapper for calculateAutoPositions to use local layoutConfig
        const calculateAutoPositionsWithConfig = (nodes, startNode) => {
            return calculateAutoPositions(nodes, startNode, layoutConfig);
        };
        
        // ============================================================
        // INTERACTIVE TREE MAP OVERLAY COMPONENT
        // ============================================================
        const TreeMapOverlay = ({ nodes, startNode, selectedNode, onSelectNode, onClose, fileName, onUpdateNodePosition, translations }) => {
            const t = { ...defaultTranslations, ...translations };
            const [selectedConnection, setSelectedConnection] = useState(null);
            const [draggingNode, setDraggingNode] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [nodePositions, setNodePositions] = useState({});
            const [svgSize, setSvgSize] = useState({ width: 800, height: 600 });
            const [multiSelectedNodes, setMultiSelectedNodes] = useState(new Set());
            const svgRef = useRef(null);

            const { nodeWidth, nodeHeight, padding } = layoutConfig;
            const GRID_SIZE = 20; // Snap-to-grid size in pixels

            // Snap value to grid
            const snapToGrid = (value) => Math.round(value / GRID_SIZE) * GRID_SIZE;

            // Initialize positions from nodes or calculate auto positions
            useEffect(() => {
                const autoLayout = calculateAutoPositionsWithConfig(nodes, startNode);
                const positions = {};
                
                Object.keys(nodes).forEach(nodeId => {
                    const savedPos = nodes[nodeId].position;
                    // Use saved position if available and not placeholder (0,0), otherwise use auto-calculated
                    if (savedPos && !(savedPos.x === 0 && savedPos.y === 0)) {
                        positions[nodeId] = { ...savedPos };
                    } else {
                        positions[nodeId] = autoLayout.positions[nodeId] || { x: padding, y: padding };
                    }
                });
                
                setNodePositions(positions);
                
                // Calculate SVG size based on node positions
                const allX = Object.values(positions).map(p => p.x);
                const allY = Object.values(positions).map(p => p.y);
                const maxX = Math.max(...allX, 400) + nodeWidth + padding;
                const maxY = Math.max(...allY, 300) + nodeHeight + padding;
                setSvgSize({ width: maxX, height: maxY });
            }, [nodes, startNode]);

            // Mouse event handlers for dragging (CTRL + drag to move)
            const handleMouseDown = (e, nodeId) => {
                if (e.button !== 0) return; // Only left click
                
                // SHIFT+click for multi-select
                if (e.shiftKey) {
                    e.stopPropagation();
                    e.preventDefault();
                    setMultiSelectedNodes(prev => {
                        const newSet = new Set(prev);
                        if (newSet.has(nodeId)) {
                            newSet.delete(nodeId);
                        } else {
                            newSet.add(nodeId);
                        }
                        return newSet;
                    });
                    return;
                }
                
                // Plain click: select this node (for Select Level, etc.)
                if (!e.ctrlKey && !e.metaKey) {
                    onSelectNode(nodeId);
                    return;
                }
                
                e.stopPropagation();
                e.preventDefault();
                
                const svg = svgRef.current;
                const pt = svg.createSVGPoint();
                pt.x = e.clientX;
                pt.y = e.clientY;
                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                
                const nodePos = nodePositions[nodeId];
                setDragOffset({
                    x: svgP.x - nodePos.x,
                    y: svgP.y - nodePos.y
                });
                setDraggingNode(nodeId);
            };

            // Double-click handler (without CTRL) - select node and close map
            const handleNodeDoubleClick = (e, nodeId) => {
                // If CTRL is held or we're dragging, don't handle as double-click
                if (e.ctrlKey || e.metaKey || draggingNode) return;

                onSelectNode(nodeId);
                onClose();
            };

            const handleMouseMove = useCallback((e) => {
                if (!draggingNode) return;
                
                const svg = svgRef.current;
                if (!svg) return;
                
                const pt = svg.createSVGPoint();
                pt.x = e.clientX;
                pt.y = e.clientY;
                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                
                // Calculate new position with snap-to-grid
                const rawX = svgP.x - dragOffset.x;
                const rawY = svgP.y - dragOffset.y;
                const newX = Math.max(nodeWidth/2, snapToGrid(rawX));
                const newY = Math.max(nodeHeight/2, snapToGrid(rawY));
                
                setNodePositions(prev => ({
                    ...prev,
                    [draggingNode]: { x: newX, y: newY }
                }));
                
                // Update SVG size if node is dragged beyond current bounds
                setSvgSize(prev => ({
                    width: Math.max(prev.width, newX + nodeWidth + padding),
                    height: Math.max(prev.height, newY + nodeHeight + padding)
                }));
            }, [draggingNode, dragOffset, nodeWidth, nodeHeight, padding, snapToGrid]);

            const handleMouseUp = useCallback(() => {
                if (draggingNode && onUpdateNodePosition) {
                    // Save the new position
                    onUpdateNodePosition(draggingNode, nodePositions[draggingNode]);
                }
                setDraggingNode(null);
            }, [draggingNode, nodePositions, onUpdateNodePosition]);

            // Add global mouse event listeners for drag
            useEffect(() => {
                if (draggingNode) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                    return () => {
                        window.removeEventListener('mousemove', handleMouseMove);
                        window.removeEventListener('mouseup', handleMouseUp);
                    };
                }
            }, [draggingNode, handleMouseMove, handleMouseUp]);

            // Reset all positions to auto-layout
            const handleResetLayout = () => {
                const autoLayout = calculateAutoPositionsWithConfig(nodes, startNode);
                setNodePositions(autoLayout.positions);
                
                // Save all reset positions
                if (onUpdateNodePosition) {
                    Object.entries(autoLayout.positions).forEach(([nodeId, pos]) => {
                        onUpdateNodePosition(nodeId, pos);
                    });
                }
                
                const allX = Object.values(autoLayout.positions).map(p => p.x);
                const allY = Object.values(autoLayout.positions).map(p => p.y);
                setSvgSize({
                    width: Math.max(...allX, 400) + nodeWidth + padding,
                    height: Math.max(...allY, 300) + nodeHeight + padding
                });
                
                // Clear multi-selection
                setMultiSelectedNodes(new Set());
            };

            // Clear multi-selection
            const handleClearSelection = () => {
                setMultiSelectedNodes(new Set());
            };

            // Select nodes at same level as the first multi-selected node
            const handleSelectSameLevel = () => {
                if (multiSelectedNodes.size === 0) return;
                const referenceNode = Array.from(multiSelectedNodes)[0];
                const currentLevel = getNodeLevel(referenceNode, nodes, startNode, levelsMap).level;
                const sameLevel = new Set();
                Object.keys(nodes).forEach(nodeId => {
                    if (getNodeLevel(nodeId, nodes, startNode, levelsMap).level === currentLevel) {
                        sameLevel.add(nodeId);
                    }
                });
                setMultiSelectedNodes(sameLevel);
            };

            // Align selected nodes horizontally (same X)
            const handleAlignHorizontally = () => {
                if (multiSelectedNodes.size < 2) return;

                const selectedArray = Array.from(multiSelectedNodes);
                const avgX = selectedArray.reduce((sum, id) => sum + nodePositions[id].x, 0) / selectedArray.length;
                const snappedX = snapToGrid(avgX);

                const newPositions = { ...nodePositions };
                selectedArray.forEach(nodeId => {
                    newPositions[nodeId] = { ...newPositions[nodeId], x: snappedX };
                    if (onUpdateNodePosition) {
                        onUpdateNodePosition(nodeId, newPositions[nodeId]);
                    }
                });
                setNodePositions(newPositions);
            };

            // Align selected nodes vertically (same Y)
            const handleAlignVertically = () => {
                if (multiSelectedNodes.size < 2) return;

                const selectedArray = Array.from(multiSelectedNodes);
                const avgY = selectedArray.reduce((sum, id) => sum + nodePositions[id].y, 0) / selectedArray.length;
                const snappedY = snapToGrid(avgY);

                const newPositions = { ...nodePositions };
                selectedArray.forEach(nodeId => {
                    newPositions[nodeId] = { ...newPositions[nodeId], y: snappedY };
                    if (onUpdateNodePosition) {
                        onUpdateNodePosition(nodeId, newPositions[nodeId]);
                    }
                });
                setNodePositions(newPositions);
            };

            // Distribute selected nodes horizontally with equal spacing
            const handleDistributeHorizontally = () => {
                if (multiSelectedNodes.size < 3) return;
                
                const selectedArray = Array.from(multiSelectedNodes);
                // Sort by current X position
                selectedArray.sort((a, b) => nodePositions[a].x - nodePositions[b].x);
                
                const minX = nodePositions[selectedArray[0]].x;
                const maxX = nodePositions[selectedArray[selectedArray.length - 1]].x;
                const spacing = (maxX - minX) / (selectedArray.length - 1);
                
                const newPositions = { ...nodePositions };
                selectedArray.forEach((nodeId, index) => {
                    const newX = snapToGrid(minX + spacing * index);
                    newPositions[nodeId] = { ...newPositions[nodeId], x: newX };
                    if (onUpdateNodePosition) {
                        onUpdateNodePosition(nodeId, newPositions[nodeId]);
                    }
                });
                setNodePositions(newPositions);
            };

            // Distribute selected nodes vertically with equal spacing
            const handleDistributeVertically = () => {
                if (multiSelectedNodes.size < 3) return;
                
                const selectedArray = Array.from(multiSelectedNodes);
                // Sort by current Y position
                selectedArray.sort((a, b) => nodePositions[a].y - nodePositions[b].y);
                
                const minY = nodePositions[selectedArray[0]].y;
                const maxY = nodePositions[selectedArray[selectedArray.length - 1]].y;
                const spacing = (maxY - minY) / (selectedArray.length - 1);
                
                const newPositions = { ...nodePositions };
                selectedArray.forEach((nodeId, index) => {
                    const newY = snapToGrid(minY + spacing * index);
                    newPositions[nodeId] = { ...newPositions[nodeId], y: newY };
                    if (onUpdateNodePosition) {
                        onUpdateNodePosition(nodeId, newPositions[nodeId]);
                    }
                });
                setNodePositions(newPositions);
            };

            // Build connections with metadata (pre-calculate BFS once)
            const levelsMap = calculateNodeLevels(nodes, startNode);
            const connections = [];
            Object.entries(nodes).forEach(([nodeId, node]) => {
                if (node.choices && nodePositions[nodeId]) {
                    node.choices.forEach((choice, idx) => { 
                        if (choice.next && nodePositions[choice.next]) {
                            const fromPos = nodePositions[nodeId];
                            const toPos = nodePositions[choice.next];
                            const fromLevel = getNodeLevel(nodeId, nodes, startNode, levelsMap).level;
                            const toLevel = getNodeLevel(choice.next, nodes, startNode, levelsMap).level;
                            connections.push({ 
                                from: fromPos, 
                                to: toPos, 
                                fromId: nodeId, 
                                toId: choice.next,
                                fromLevel,
                                toLevel,
                                isLoop: toLevel < fromLevel,
                                isSameLevel: toLevel === fromLevel,
                                key: `${nodeId}-${choice.next}-${idx}`
                            }); 
                        }
                    });
                }
            });
            
            const isTerminal = (nodeId) => !nodes[nodeId]?.choices || nodes[nodeId].choices.length === 0;
            const isOrphan = (nodeId) => getNodeLevel(nodeId, nodes, startNode, levelsMap).level === 0;
            
            // Map connection utilities from shared-utils
            const getConnectionPath = (conn) => sharedGetConnectionPath(conn, nodeHeight);
            const getArrowPosition = sharedGetArrowPosition;

            // Editor-specific: adds selected/hovered highlight on top of shared colors
            const getConnectionColor = (conn, isSelected, isHovered) => {
                if (isSelected || isHovered) return '#6366f1';
                return sharedGetConnectionColor(conn);
            };
            
            return (
                <div className="map-overlay">
                    <div className="map-overlay-header">
                        <h2>{fileName || 'Scenario Map'}</h2>
                        <div className="map-legend">
                            <span><span className="legend-dot legend-start"></span> Start</span>
                            <span><span className="legend-dot legend-terminal"></span> Terminal</span>
                            <span><span className="legend-dot legend-selected"></span> Selected</span>
                            <span><span className="legend-dot legend-orphan"></span> Orphan</span>
                            <span><span className="legend-dot legend-multiselect"></span> Multi-select</span>
                        </div>
                        <div className="map-toolbar">
                            {multiSelectedNodes.size > 0 && (
                                <>
                                    <span className="text-muted" style={{ fontSize: '0.75rem' }}>{multiSelectedNodes.size} selected</span>
                                    <button className="btn btn-secondary" onClick={handleClearSelection} title="Clear selection">‚úï</button>
                                    <div className="separator"></div>
                                    <button className="btn btn-secondary" onClick={handleAlignHorizontally} title="Align horizontally (same X)" disabled={multiSelectedNodes.size < 2}>‚ïê {t.mapAlignH}</button>
                                    <button className="btn btn-secondary" onClick={handleAlignVertically} title="Align vertically (same Y)" disabled={multiSelectedNodes.size < 2}>‚ïë {t.mapAlignV}</button>
                                    <div className="separator"></div>
                                    <button className="btn btn-secondary" onClick={handleDistributeHorizontally} title="Distribute horizontally (equal X spacing)" disabled={multiSelectedNodes.size < 3}>‚ü∑ {t.mapDistribH}</button>
                                    <button className="btn btn-secondary" onClick={handleDistributeVertically} title="Distribute vertically (equal Y spacing)" disabled={multiSelectedNodes.size < 3}>‚Üï {t.mapDistribV}</button>
                                    <div className="separator"></div>
                                    <button className="btn btn-secondary" onClick={handleSelectSameLevel} title="Select all nodes at same level">{t.mapSelectLevel}</button>
                                </>
                            )}
                            <button className="btn btn-secondary" onClick={handleResetLayout} title="Reset to automatic layout">
                                ‚Üª {t.mapAutoLayout}
                            </button>
                            <button className="btn btn-close" onClick={onClose}>X</button>
                        </div>
                    </div>
                    <div className="map-overlay-content">
                        <svg 
                            ref={svgRef}
                            width={svgSize.width} 
                            height={svgSize.height} 
                            style={{ display: 'block', margin: 'auto', cursor: draggingNode ? 'grabbing' : 'default', background: '#ffffff', border: '1px solid #e5e7eb', borderRadius: '8px' }}
                        >
                            {/* Connections with midpoint arrows */}
                            {connections.map((conn) => {
                                const isSelected = selectedConnection === conn.key;
                                const pathData = getConnectionPath(conn);
                                const arrowPos = getArrowPosition(pathData);
                                const color = getConnectionColor(conn, isSelected, false);

                                return (
                                    <g key={conn.key}>
                                        {/* Invisible wider path for easier clicking */}
                                        <path
                                            d={pathData.path}
                                            fill="none"
                                            stroke="transparent"
                                            strokeWidth={15}
                                            style={{ cursor: 'pointer' }}
                                            onClick={() => setSelectedConnection(isSelected ? null : conn.key)}
                                        />
                                        {/* Visible path */}
                                        <path
                                            d={pathData.path}
                                            fill="none"
                                            stroke={color}
                                            strokeWidth={isSelected ? 3 : 2}
                                            style={{ cursor: 'pointer', transition: 'stroke 0.2s, stroke-width 0.2s' }}
                                            onClick={() => setSelectedConnection(isSelected ? null : conn.key)}
                                            onMouseEnter={(e) => {
                                                if (!isSelected) {
                                                    e.target.setAttribute('stroke', '#6366f1');
                                                    e.target.setAttribute('stroke-width', '3');
                                                    e.target.nextSibling?.setAttribute('fill', '#6366f1');
                                                }
                                            }}
                                            onMouseLeave={(e) => {
                                                if (!isSelected) {
                                                    e.target.setAttribute('stroke', getConnectionColor(conn, false, false));
                                                    e.target.setAttribute('stroke-width', '2');
                                                    e.target.nextSibling?.setAttribute('fill', getConnectionColor(conn, false, false));
                                                }
                                            }}
                                        />
                                        {/* Arrow at midpoint */}
                                        <polygon
                                            points="-10,-6 10,0 -10,6"
                                            fill={color}
                                            transform={`translate(${arrowPos.x}, ${arrowPos.y}) rotate(${arrowPos.angle})`}
                                            style={{ cursor: 'pointer', transition: 'fill 0.2s' }}
                                            onClick={() => setSelectedConnection(isSelected ? null : conn.key)}
                                        />
                                    </g>
                                );
                            })}
                            
                            {/* Nodes - click to select, SHIFT+click for multi-select, CTRL+drag to move */}
                            {Object.entries(nodePositions).map(([nodeId, pos]) => {
                                if (!nodes[nodeId]) return null;
                                const isSelected = nodeId === selectedNode;
                                const isMultiSelected = multiSelectedNodes.has(nodeId);
                                const isStart = nodeId === startNode;
                                const isEnd = isTerminal(nodeId);
                                const orphan = isOrphan(nodeId);
                                const isDragging = draggingNode === nodeId;
                                
                                let fill = '#f3f4f6', stroke = '#9ca3af', sw = 2, textFill = '#374151';
                                if (isMultiSelected) { fill = '#fce7f3'; stroke = '#ec4899'; sw = 3; textFill = '#9d174d'; }
                                else if (isSelected) { fill = '#e0e7ff'; stroke = '#818cf8'; sw = 3; textFill = '#3730a3'; }
                                if (isStart) stroke = '#10b981'; else if (orphan) stroke = '#ef4444'; else if (isEnd) stroke = '#f59e0b';
                                
                                const content = nodes[nodeId]?.content || '';
                                const title = content.match(/^#\s+(.+)$/m)?.[1]?.slice(0, 15) || nodeId;
                                
                                return (
                                    <g 
                                        key={nodeId} 
                                        className={`draggable-node ${isDragging ? 'dragging' : ''}`}
                                        style={{ cursor: isDragging ? 'grabbing' : 'pointer' }}
                                        onMouseDown={(e) => handleMouseDown(e, nodeId)}
                                        onDoubleClick={(e) => handleNodeDoubleClick(e, nodeId)}
                                    >
                                        <rect 
                                            x={pos.x - nodeWidth/2 + 10} 
                                            y={pos.y - nodeHeight/2} 
                                            width={nodeWidth - 20} 
                                            height={nodeHeight} 
                                            rx={8} 
                                            fill={fill} 
                                            stroke={stroke} 
                                            strokeWidth={sw}
                                            style={{ filter: isDragging ? 'drop-shadow(0 4px 6px rgba(0,0,0,0.2))' : 'none' }}
                                        />
                                        <text 
                                            x={pos.x} 
                                            y={pos.y - 6} 
                                            textAnchor="middle" 
                                            dominantBaseline="middle" 
                                            fill={textFill} 
                                            fontSize="11" 
                                            fontWeight="500"
                                            style={{ pointerEvents: 'none', userSelect: 'none' }}
                                        >
                                            {title.length > 15 ? title.slice(0, 12) + '...' : title}
                                        </text>
                                        <text 
                                            x={pos.x} 
                                            y={pos.y + 10} 
                                            textAnchor="middle" 
                                            dominantBaseline="middle" 
                                            fill="#6b7280" 
                                            fontSize="9" 
                                            fontFamily="monospace"
                                            style={{ pointerEvents: 'none', userSelect: 'none' }}
                                        >
                                            {nodeId.length > 14 ? nodeId.slice(0, 12) + '..' : nodeId}
                                        </text>
                                    </g>
                                );
                            })}
                        </svg>
                    </div>
                    <div style={{ padding: '0.75rem 1.5rem', borderTop: '1px solid #e5e7eb', background: '#f9fafb', fontSize: '0.8rem', color: '#6b7280' }}>
                        üí° Double-click to edit ‚Ä¢ CTRL+drag to reposition (snaps to grid) ‚Ä¢ SHIFT+click to multi-select ‚Ä¢ Positions saved automatically
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // SCENARIO FACTORY
        // ============================================================
        const createEmptyScenario = () => {
            return {
                meta: { title: '[Your Scenario Title]', description: '[Brief description of this scenario]', author: '[Your Name]' },
                translations: { ...defaultTranslations },
                startNode: 'start',
                nodes: { start: { content: '# [Your First Node Title]\n\nReplace this text with your content. Use Markdown for formatting.\n\nThen add choices below to connect to other nodes.', level: 1, position: { x: 0, y: 0 }, choices: [], resources: [] } }
            };
        };
        
        // ============================================================
        // NODE LIST COMPONENT
        // ============================================================
        const NodeList = ({ scenario, selectedNode, onSelectNode, startNode }) => {
            const nodeIds = Object.keys(scenario.nodes);
            const levelsMap = calculateNodeLevels(scenario.nodes, startNode);
            const getNodeTitle = (nodeId) => { const c = scenario.nodes[nodeId]?.content || ''; const m = c.match(/^#\s+(.+)$/m); return m ? m[1].replace(/\*\*/g, '').slice(0, 30) : 'Untitled'; };
            const isTerminal = (nodeId) => (scenario.nodes[nodeId]?.choices || []).length === 0;
            const getNodeLevelInfo = (nodeId) => { const info = getNodeLevel(nodeId, scenario.nodes, startNode, levelsMap); return info.level === 0 ? 'orphan' : `L${info.level}-P${info.position}`; };
            return (
                <div className="node-list">
                    {nodeIds.map(nodeId => (
                        <div key={nodeId} className={`node-item ${selectedNode === nodeId ? 'selected' : ''} ${nodeId === startNode ? 'start-node' : ''} ${isTerminal(nodeId) ? 'terminal' : ''}`} onClick={() => onSelectNode(nodeId)}>
                            <div className="node-title">{getNodeTitle(nodeId)}</div>
                            <div className="node-id-small">{nodeId}</div>
                            <div className="node-badges">
                                <span className="badge">{getNodeLevelInfo(nodeId)}</span>
                                {nodeId === startNode && <span className="badge badge-start">START</span>}
                                {isTerminal(nodeId) && <span className="badge badge-terminal">END</span>}
                            </div>
                        </div>
                    ))}
                </div>
            );
        };
        
    // ============================================================
    // CREATE NODE POPUP COMPONENT
    // ============================================================
    const CreateNodePopup = ({ parentNodeId, parentLevel, existingNodeIds, onCreateNode, onCreated, onClose }) => {
        const suggestId = () => { let base = `${parentNodeId}_child`, c = 1, id = base; while (existingNodeIds.includes(id)) { id = `${base}_${c}`; c++; } return id; };
        const [nodeId, setNodeId] = useState(suggestId());
        const [content, setContent] = useState('# New Node\n\nEdit this content.');
        const [level, setLevel] = useState(parentLevel + 1);
        const [errors, setErrors] = useState({ id: '', content: '' });

        const handleCreate = () => {
            const cleanId = nodeId.trim().replace(/[^a-zA-Z0-9_]/g, '_');
            const cleanContent = content.trim();
            const newErrors = { id: '', content: '' };
            let hasError = false;

            // Validate Node ID
            if (!cleanId) {
                newErrors.id = 'Node ID is required';
                hasError = true;
            } else if (existingNodeIds.includes(cleanId)) {
                newErrors.id = 'ID already exists';
                hasError = true;
            }

            // Validate Content
            if (!cleanContent) {
                newErrors.content = 'Node content is required';
                hasError = true;
            }

            setErrors(newErrors);

            if (hasError) return;

            // Include level and placeholder position in the new node
            onCreateNode(cleanId, { content: cleanContent, level: level, position: { x: 0, y: 0 }, choices: [], resources: [] });
            onCreated(cleanId);
        };

        return (
            <div className="modal-overlay">
                <div className="modal-content">
                                        <div className="modal-header"><h3>Create New Node</h3><button className="btn btn-close" onClick={onClose} style={{ padding: '0.25rem 0.5rem' }}>‚úï</button></div>
                    <div className="form-group">
                        <label className="form-label">
                            Node ID <span className="required-star">*</span>
                        </label>
                        <input
                            type="text"
                            value={nodeId}
                            onChange={(e) => { setNodeId(e.target.value); setErrors(prev => ({ ...prev, id: '' })); }}
                            className={errors.id ? 'form-input input-error' : 'form-input'}
                        />
                        {errors.id && <div style={errorMessageStyle}><span>‚ö†Ô∏è</span> {errors.id}</div>}
                    </div>
                    <div className="form-group">
                        <label className="form-label">
                            Node content <span className="required-star">*</span>
                        </label>
                        <textarea
                            className={errors.content ? 'form-input input-error' : 'form-input'}
                            rows={4}
                            value={content}
                            onChange={(e) => { setContent(e.target.value); setErrors(prev => ({ ...prev, content: '' })); }}
                        />
                        {errors.content && <div style={errorMessageStyle}><span>‚ö†Ô∏è</span> {errors.content}</div>}
                    </div>
                    <div className="form-group">
                        <label className="form-label">Level</label>
                        <input
                            type="number"
                            className="form-input"
                            value={level}
                            onChange={(e) => setLevel(parseInt(e.target.value) || 1)}
                            min="1"
                            style={{ width: '80px' }}
                        />
                        <span style={{ fontSize: '0.75rem', color: '#6b7280', marginLeft: '0.5rem' }}>Default: parent level + 1</span>
                    </div>
                    <div style={{ display: 'flex', gap: '0.5rem', marginTop: '1rem' }}>
                        <button className="btn btn-success" onClick={handleCreate}>Create</button>
                        <button className="btn btn-danger" onClick={onClose}>CANCEL</button>
                    </div>
                </div>
            </div>
        );
    };
        
        // ============================================================
        // SHARED UI HELPERS
        // ============================================================

        let _nextId = 1;
        const generateId = () => '__id_' + (_nextId++) + '_' + Math.random().toString(36).slice(2, 7);

        /** Ensure every item in an array has a stable _id */
        const ensureIds = (items) => {
            if (!items) return [];
            return items.map(item => item._id ? item : { ...item, _id: generateId() });
        };

        const errorMessageStyle = { color: '#ef4444', fontSize: '0.75rem', marginTop: '0.35rem', display: 'flex', alignItems: 'center', gap: '0.25rem' };

        /**
         * Get border style for editor items based on validation state
         * @param {boolean} hasErrors - Whether any validation errors exist
         * @param {boolean} hasUnsavedChanges - Whether there are unsaved changes
         * @param {boolean} isComplete - Whether all required fields are filled
         * @returns {Object} - React inline style object
         */
        const getBorderStyle = (hasErrors, hasUnsavedChanges, isComplete) => {
            if (hasErrors) return { borderColor: '#ef4444' };
            if (hasUnsavedChanges) return { borderColor: '#f59e0b', boxShadow: '0 0 0 2px rgba(245, 158, 11, 0.2)' };
            if (isComplete) return { borderColor: '#10b981' };
            return {};
        };

        // ============================================================
        // CHOICE EDITOR COMPONENT
        // ============================================================
        const ChoiceEditor = ({ choice, index, nodeIds, parentNodeId, nodes, startNode, siblingChoices, onChange, onRemove, onMoveUp, onMoveDown, isFirst, isLast, onCreateNode }) => {
            const [showCreate, setShowCreate] = useState(false);
            const [localText, setLocalText] = useState(choice.text || '');
            const [localTarget, setLocalTarget] = useState(choice.next || '');
            const [errors, setErrors] = useState({ text: null, target: null });
            const [pendingTarget, setPendingTarget] = useState(null);

            // Get parent level for default child level calculation
            const parentLevel = getEffectiveLevel(parentNodeId, nodes, startNode);

            // Get targets already used by other choices (excluding current choice)
            const usedTargets = siblingChoices
                .filter((c, i) => i !== index && c.next)
                .map(c => c.next);

            // Check if local values differ from saved values
            const hasUnsavedChanges = localText !== (choice.text || '') || localTarget !== (choice.next || '');
            const isComplete = (choice.text || '').trim() && (choice.next || '');

            // Sync local state when choice prop changes (e.g., after node creation)
            useEffect(() => {
                setLocalText(choice.text || '');
                setLocalTarget(choice.next || '');
            }, [choice.text, choice.next]);

            const handleTextChange = (e) => {
                setLocalText(e.target.value);
                if (e.target.value.trim()) {
                    setErrors(prev => ({ ...prev, text: null }));
                }
            };

            const handleTargetChange = (e) => {
                const newTarget = e.target.value;

                if (newTarget === '__CREATE__') {
                    // Store that we want to create a node, but need to save first
                    if (!localText.trim()) {
                        setErrors({ text: 'Button text required', target: null });
                        return;
                    }
                    setPendingTarget('__CREATE__');
                    setShowCreate(true);
                } else {
                    setLocalTarget(newTarget);
                    setPendingTarget(null);
                    if (newTarget) {
                        setErrors(prev => ({ ...prev, target: null }));
                    }
                }
            };

            const handleNodeCreated = (newNodeId) => {
                setLocalTarget(newNodeId);
                setPendingTarget(null);
                setShowCreate(false);
                // Auto-save after creating node since both fields are now complete
                if (localText.trim()) {
                    onChange({ ...choice, text: localText.trim(), next: newNodeId });
                    setErrors({ text: null, target: null });
                }
            };

            const handleSave = () => {
                const newErrors = { text: null, target: null };
                let hasError = false;

                if (!localText.trim()) {
                    newErrors.text = 'Button text is required';
                    hasError = true;
                }

                if (!localTarget) {
                    newErrors.target = 'Target node is required';
                    hasError = true;
                }

                setErrors(newErrors);

                if (!hasError) {
                    onChange({ ...choice, text: localText.trim(), next: localTarget });
                }
            };

            return (
                <div className="choice-item" style={getBorderStyle(!!(errors.text || errors.target), hasUnsavedChanges, isComplete)}>
                    <div className="choice-header">
                        <span className="choice-number">
                            Choice {index + 1}
                            {hasUnsavedChanges && <span className="text-warning status-indicator">‚óè unsaved</span>}
                            {isComplete && !hasUnsavedChanges && <span className="text-success status-indicator">‚úì</span>}
                        </span>
                        <div style={{ display: 'flex', gap: '0.25rem', alignItems: 'center' }}>
                            <button className="btn btn-secondary" onClick={onMoveUp} disabled={isFirst} style={{ padding: '0.15rem 0.4rem', fontSize: '0.75rem', opacity: isFirst ? 0.3 : 1, cursor: isFirst ? 'default' : 'pointer' }} title="Move up">‚ñ≤</button>
                            <button className="btn btn-secondary" onClick={onMoveDown} disabled={isLast} style={{ padding: '0.15rem 0.4rem', fontSize: '0.75rem', opacity: isLast ? 0.3 : 1, cursor: isLast ? 'default' : 'pointer' }} title="Move down">‚ñº</button>
                            <button className="btn btn-danger" onClick={onRemove} style={{ padding: '0.25rem 0.5rem', fontSize: '0.75rem' }}>REMOVE</button>
                        </div>
                    </div>
                    <div className="form-group">
                        <label className="form-label">
                            Button Text <span className="required-star">*</span>
                        </label>
                        <input
                            type="text"
                            className={errors.text ? 'form-input input-error' : 'form-input'}
                            value={localText}
                            onChange={handleTextChange}
                            placeholder="Enter button text"
                        />
                        {errors.text && (
                            <div style={errorMessageStyle}>
                                <span>‚ö†Ô∏è</span> {errors.text}
                            </div>
                        )}
                    </div>
                    <div className="form-group">
                        <label className="form-label">
                            Target Node <span className="required-star">*</span>
                        </label>
                        <select
                            className={errors.target ? 'form-select input-error' : 'form-select'}
                            value={localTarget}
                            onChange={handleTargetChange}
                        >
                            <option value="">-- Select target --</option>
                            <option value="__CREATE__" style={{ fontWeight: 'bold', color: '#10b981' }}>+ Create new node...</option>
                            {nodeIds.filter(id => id !== parentNodeId && !usedTargets.includes(id)).map(id => <option key={id} value={id}>{id}</option>)}
                        </select>
                        {errors.target && (
                            <div style={errorMessageStyle}>
                                <span>‚ö†Ô∏è</span> {errors.target}
                            </div>
                        )}
                    </div>
                    <div style={{ marginTop: '0.75rem' }}>
                        <button className="btn btn-success" onClick={handleSave} style={{ width: '100%' }}>
                            Save Choice
                        </button>
                    </div>
                                        {showCreate && <CreateNodePopup parentNodeId={parentNodeId} parentLevel={parentLevel} existingNodeIds={nodeIds} onCreateNode={onCreateNode} onCreated={handleNodeCreated} onClose={() => { setShowCreate(false); setPendingTarget(null); }} />}
                </div>
            );
        };
        
        // ============================================================
        // RESOURCE EDITOR COMPONENT
        // ============================================================
        const ResourceEditor = ({ resource, index, onChange, onRemove }) => {
            const [localType, setLocalType] = useState(resource.type || '');
            const [localUrl, setLocalUrl] = useState(resource.url || '');
            const [localLabel, setLocalLabel] = useState(resource.label || '');
            const [errors, setErrors] = useState({ type: null, url: null, label: null });

            // Check if local values differ from saved values
            const hasUnsavedChanges = localType !== (resource.type || '') || localUrl !== (resource.url || '') || localLabel !== (resource.label || '');
            const isComplete = (resource.type || '').trim() && (resource.url || '').trim() && (resource.label || '').trim();

            // Sync local state when resource prop changes
            useEffect(() => {
                setLocalType(resource.type || '');
                setLocalUrl(resource.url || '');
                setLocalLabel(resource.label || '');
            }, [resource.type, resource.url, resource.label]);

            const handleTypeChange = (e) => {
                setLocalType(e.target.value);
                if (e.target.value) {
                    setErrors(prev => ({ ...prev, type: null }));
                }
            };

            const handleUrlChange = (e) => {
                setLocalUrl(e.target.value);
                if (e.target.value.trim()) {
                    setErrors(prev => ({ ...prev, url: null }));
                }
            };

            const handleLabelChange = (e) => {
                setLocalLabel(e.target.value);
                if (e.target.value.trim()) {
                    setErrors(prev => ({ ...prev, label: null }));
                }
            };

            const handleSave = () => {
                const newErrors = { type: null, url: null, label: null };
                let hasError = false;

                if (!localType) {
                    newErrors.type = 'Type is required';
                    hasError = true;
                }

                if (!localUrl.trim()) {
                    newErrors.url = 'URL is required';
                    hasError = true;
                }

                if (!localLabel.trim()) {
                    newErrors.label = 'Label is required';
                    hasError = true;
                }

                setErrors(newErrors);

                if (!hasError) {
                    const safeUrl = sanitizeUrl(localUrl.trim());
                    if (!safeUrl) {
                        setErrors(prev => ({ ...prev, url: 'Invalid or unsafe URL' }));
                        return;
                    }
                    onChange({ ...resource, type: localType, url: safeUrl, label: localLabel.trim() });
                }
            };

            return (
                <div className="resource-item" style={getBorderStyle(!!(errors.type || errors.url || errors.label), hasUnsavedChanges, isComplete)}>
                    <div className="resource-header">
                        <span className="choice-number">
                            Resource {index + 1}
                            {hasUnsavedChanges && <span className="text-warning status-indicator">‚óè unsaved</span>}
                            {isComplete && !hasUnsavedChanges && <span className="text-success status-indicator">‚úì</span>}
                        </span>
                        <button className="btn btn-danger" onClick={onRemove} style={{ padding: '0.25rem 0.5rem', fontSize: '0.75rem' }}>REMOVE</button>
                    </div>
                    <div className="form-row">
                        <div className="form-group">
                            <label className="form-label">
                                Type <span className="required-star">*</span>
                            </label>
                            <select
                                className={errors.type ? 'form-select input-error' : 'form-select'}
                                value={localType}
                                onChange={handleTypeChange}
                            >
                                <option value="">-- Select type --</option>
                                <option value="link">Link</option>
                                <option value="download">Download</option>
                                <option value="video">Video</option>
                            </select>
                            {errors.type && (
                                <div style={errorMessageStyle}>
                                    <span>‚ö†Ô∏è</span> {errors.type}
                                </div>
                            )}
                        </div>
                        <div className="form-group">
                            <label className="form-label">
                                URL <span className="required-star">*</span>
                            </label>
                            <input
                                type="text"
                                className={errors.url ? 'form-input input-error' : 'form-input'}
                                value={localUrl}
                                onChange={handleUrlChange}
                                placeholder="https://..."
                            />
                            {errors.url && (
                                <div style={errorMessageStyle}>
                                    <span>‚ö†Ô∏è</span> {errors.url}
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="form-group">
                        <label className="form-label">
                            Label <span className="required-star">*</span>
                        </label>
                        <input
                            type="text"
                            className={errors.label ? 'form-input input-error' : 'form-input'}
                            value={localLabel}
                            onChange={handleLabelChange}
                            placeholder="Resource description"
                        />
                        {errors.label && (
                            <div style={errorMessageStyle}>
                                <span>‚ö†Ô∏è</span> {errors.label}
                            </div>
                        )}
                    </div>
                    <div style={{ marginTop: '0.75rem' }}>
                        <button className="btn btn-success" onClick={handleSave} style={{ width: '100%' }}>
                            Save Resource
                        </button>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // NODE EDITOR COMPONENT
        // ============================================================
        // ============================================================
        // RESIZABLE TEXTAREA COMPONENT
        // ============================================================
        const ResizableTextarea = ({ value, onChange, placeholder, minHeight = 120 }) => {
            const [height, setHeight] = useState(minHeight);
            const containerRef = useRef(null);
            const isDragging = useRef(false);
            const startY = useRef(0);
            const startHeight = useRef(0);

            const handleMouseDown = (e) => {
                isDragging.current = true;
                startY.current = e.clientY;
                startHeight.current = height;
                document.body.style.cursor = 'ns-resize';
                document.body.style.userSelect = 'none';
            };

            useEffect(() => {
                const handleMouseMove = (e) => {
                    if (!isDragging.current) return;
                    const delta = e.clientY - startY.current;
                    const newHeight = Math.max(minHeight, startHeight.current + delta);
                    setHeight(newHeight);
                };

                const handleMouseUp = () => {
                    if (isDragging.current) {
                        isDragging.current = false;
                        document.body.style.cursor = '';
                        document.body.style.userSelect = '';
                    }
                };

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [minHeight]);

            return (
                <div className="textarea-container" ref={containerRef}>
                    <textarea 
                        className="form-input form-textarea" 
                        style={{ height: `${height}px`, borderRadius: '6px 6px 0 0' }}
                        value={value} 
                        onChange={onChange} 
                        placeholder={placeholder}
                    />
                    <div className="resize-handle" onMouseDown={handleMouseDown} title="Drag to resize" />
                </div>
            );
        };

        // ============================================================
        // NODE EDITOR COMPONENT
        // ============================================================
        const NodeEditor = ({ nodeId, node, nodeIds, nodes, startNode, onUpdateNode, onDeleteNode, onRenameNode, onCreateNode }) => {
            const [newNodeId, setNewNodeId] = useState(nodeId);
            const [showRename, setShowRename] = useState(false);

            // Get calculated level for display
            const calculatedLevel = getEffectiveLevel(nodeId, nodes, startNode);
            const hasExplicitLevel = node.level !== undefined && node.level !== null && node.level !== '';

            useEffect(() => { setNewNodeId(nodeId); setShowRename(false); }, [nodeId]);

            const handleRename = () => { if (newNodeId && newNodeId !== nodeId && !nodeIds.includes(newNodeId)) { onRenameNode(nodeId, newNodeId); setShowRename(false); } };
            const updateContent = (value) => onUpdateNode(nodeId, { ...node, content: value });
            const updateLevel = (value) => {
                const newLevel = value === '' ? undefined : parseInt(value);
                onUpdateNode(nodeId, { ...node, level: newLevel });
            };
            const updateChoice = (i, c) => { const nc = [...(node.choices || [])]; nc[i] = c; onUpdateNode(nodeId, { ...node, choices: nc }); };
            const addChoice = () => onUpdateNode(nodeId, { ...node, choices: [...(node.choices || []), { text: '', next: '', _id: generateId() }] });
            const removeChoice = (i) => onUpdateNode(nodeId, { ...node, choices: (node.choices || []).filter((_, idx) => idx !== i) });
            const moveChoiceUp = (i) => { if (i <= 0) return; const nc = [...(node.choices || [])]; [nc[i - 1], nc[i]] = [nc[i], nc[i - 1]]; onUpdateNode(nodeId, { ...node, choices: nc }); };
            const moveChoiceDown = (i) => { const nc = [...(node.choices || [])]; if (i >= nc.length - 1) return; [nc[i], nc[i + 1]] = [nc[i + 1], nc[i]]; onUpdateNode(nodeId, { ...node, choices: nc }); };
            const updateResource = (i, r) => { const nr = [...(node.resources || [])]; nr[i] = r; onUpdateNode(nodeId, { ...node, resources: nr }); };
            const addResource = () => onUpdateNode(nodeId, { ...node, resources: [...(node.resources || []), { type: 'link', label: '', url: '', _id: generateId() }] });
            const removeResource = (i) => onUpdateNode(nodeId, { ...node, resources: (node.resources || []).filter((_, idx) => idx !== i) });

            return (
                <div className="editor-content">
                    <div className="form-section">
                        <h3>Node: {nodeId} {nodeId === startNode && <span className="badge badge-start" style={{ marginLeft: '0.5rem' }}>START</span>}</h3>
                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                            {!showRename ? <button className="btn btn-secondary" onClick={() => setShowRename(true)}>Rename</button> : (
                                <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                    <input type="text" className="form-input" style={{ width: '150px' }} value={newNodeId} onChange={(e) => setNewNodeId(e.target.value.replace(/[^a-zA-Z0-9_]/g, ''))} />
                                    <button className="btn btn-primary" onClick={handleRename}>OK</button>
                                    <button className="btn btn-danger" onClick={() => { setShowRename(false); setNewNodeId(nodeId); }}>Cancel</button>
                                </div>
                            )}
                            {nodeId !== startNode && <button className="btn btn-danger" onClick={() => onDeleteNode(nodeId)}>Delete</button>}
                        </div>
                    </div>

                    <div className="form-section">
                        <h3>üìù Content</h3>
                        <div className="form-group">
                            <label className="form-label">Content - Markdown</label>
                            <ResizableTextarea value={node.content || ''} onChange={(e) => updateContent(e.target.value)} placeholder="# Title&#10;&#10;Content..." />
                        </div>
                    </div>

                    <div className="form-section">
                        <h3>üìä Level</h3>
                        <div className="form-group">
                            <div style={{ display: 'flex', alignItems: 'center', gap: '1rem' }}>
                                <div>
                                    <label className="form-label">Override Level</label>
                                    <input 
                                        type="number" 
                                        className="form-input" 
                                        value={node.level !== undefined && node.level !== null ? node.level : ''} 
                                        onChange={(e) => updateLevel(e.target.value)}
                                        min="1"
                                        placeholder="Auto"
                                        style={{ width: '80px' }}
                                    />
                                </div>
                                <div style={{ fontSize: '0.85rem', color: '#6b7280' }}>
                                    {hasExplicitLevel ? (
                                        <span>
                                            Explicit: <strong style={{ color: '#10b981' }}>L{node.level}</strong>
                                            <button 
                                                className="btn btn-secondary" 
                                                onClick={() => updateLevel('')}
                                                style={{ marginLeft: '0.5rem', padding: '0.2rem 0.5rem', fontSize: '0.7rem' }}
                                            >
                                                Reset to Auto
                                            </button>
                                        </span>
                                    ) : (
                                        <span>Auto-calculated: <strong>L{calculatedLevel}</strong></span>
                                    )}
                                </div>
                            </div>
                            <p style={{ fontSize: '0.75rem', color: '#9ca3af', marginTop: '0.5rem' }}>
                                Leave empty for automatic level calculation. Set explicitly to override for correct loop coloring.
                            </p>
                        </div>
                    </div>

                    <div className="form-section">
                        <h3>üîÄ Choices ({(node.choices || []).length})</h3>
                        {(node.choices || []).map((choice, i) => <ChoiceEditor key={choice._id || i} choice={choice} index={i} nodeIds={nodeIds} parentNodeId={nodeId} nodes={nodes} startNode={startNode} siblingChoices={node.choices || []} onChange={(c) => updateChoice(i, c)} onRemove={() => removeChoice(i)} onMoveUp={() => moveChoiceUp(i)} onMoveDown={() => moveChoiceDown(i)} isFirst={i === 0} isLast={i === (node.choices || []).length - 1} onCreateNode={onCreateNode} />)}
                        <button className="btn btn-success" onClick={addChoice}>+ Add Choice</button>
                        {(node.choices || []).length === 0 && <p style={{ fontSize: '0.8rem', color: '#9ca3af', marginTop: '0.5rem', textAlign: 'center' }}>No choices = terminal node</p>}
                    </div>

                    <div className="form-section">
                        <h3>üìé Resources ({(node.resources || []).length})</h3>
                        {(node.resources || []).map((r, i) => <ResourceEditor key={r._id || i} resource={r} index={i} onChange={(res) => updateResource(i, res)} onRemove={() => removeResource(i)} />)}
                        <button className="btn btn-success" onClick={addResource}>+ Add Resource</button>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // META EDITOR COMPONENT
        // ============================================================
        const MetaEditor = ({ meta, translations, onUpdate, onClose }) => {
            const [localMeta, setLocalMeta] = useState(meta);
            const [localTrans, setLocalTrans] = useState(translations);
            const handleSave = () => { onUpdate(localMeta, localTrans); onClose(); };
            return (
                <div className="modal-overlay">
                    <div className="modal-content" style={{ maxWidth: '650px' }}>
                        <div className="modal-header"><h2>Scenario Settings</h2><button className="btn btn-close" onClick={onClose}>‚úï</button></div>
                        <div className="form-group">
                            <label className="form-label">Title</label>
                            <input type="text" className="form-input" value={localMeta.title || ''} onChange={(e) => setLocalMeta({ ...localMeta, title: e.target.value })} />
                        </div>
                        <div className="form-group">
                            <label className="form-label">Description</label>
                            <textarea className="form-input" rows={2} value={localMeta.description || ''} onChange={(e) => setLocalMeta({ ...localMeta, description: e.target.value })} />
                        </div>
                        <div className="form-group">
                            <label className="form-label">Author</label>
                            <input type="text" className="form-input" value={localMeta.author || ''} onChange={(e) => setLocalMeta({ ...localMeta, author: e.target.value })} />
                        </div>
                        <hr style={{ borderColor: '#374151', margin: '1rem 0' }} />
                        <h4 style={{ color: '#111827', marginBottom: '0.75rem' }}>UI Labels</h4>
                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.5rem' }}>
                            {Object.keys(defaultTranslations).map(key => (
                                <div key={key} className="form-group" style={{ marginBottom: '0.5rem' }}>
                                    <label className="form-label" style={{ fontSize: '0.7rem' }}>{key}</label>
                                    <input type="text" className="form-input" style={{ padding: '0.4rem', fontSize: '0.8rem' }} value={localTrans?.[key] || ''} onChange={(e) => setLocalTrans({ ...localTrans, [key]: e.target.value })} />
                                </div>
                            ))}
                        </div>
                        <div style={{ display: 'flex', gap: '0.5rem', marginTop: '1rem' }}>
                            <button className="btn btn-primary" onClick={handleSave}>Save</button>
                            <button className="btn btn-danger" onClick={onClose}>Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // MAIN SCENARIO EDITOR COMPONENT
        // ============================================================
        const ScenarioEditor = () => {
            // Initialize with empty scenario directly (no welcome screen)
            const [scenario, setScenario] = useState(() => createEmptyScenario());
            const [selectedNode, setSelectedNode] = useState('start');
            const [hasChanges, setHasChanges] = useState(false);
            const [showMetaEditor, setShowMetaEditor] = useState(false);
            const [showMap, setShowMap] = useState(false);
            const [showSidebar, setShowSidebar] = useState(true);
            const [fileName, setFileName] = useState(null);
            const [layoutLoaded, setLayoutLoaded] = useState(false);
            const [saveWarnings, setSaveWarnings] = useState(null);
            const fileInputRef = useRef(null);

            // Load defaults.json (layout) and config.json (scenario to open)
            useEffect(() => {
                const cacheBuster = '?v=' + Date.now();
                fetch('defaults.json' + cacheBuster)
                    .then(res => res.ok ? res.json() : null)
                    .then(data => {
                        if (data?.layout) {
                            layoutConfig = { ...layoutConfig, ...data.layout };
                        }
                        return fetch('config.json' + cacheBuster);
                    })
                    .then(res => res.ok ? res.json() : null)
                    .then(config => {
                        if (!config?.scenario) {
                            setLayoutLoaded(true);
                            return;
                        }
                        return fetch(config.scenario + cacheBuster)
                            .then(res => {
                                if (!res.ok) throw new Error('Not found');
                                return res.json();
                            })
                            .then(data => {
                                // Assign stable _id to choices and resources
                                Object.keys(data.nodes).forEach(id => {
                                    data.nodes[id].choices = ensureIds(data.nodes[id].choices);
                                    data.nodes[id].resources = ensureIds(data.nodes[id].resources);
                                });
                                setScenario(data);
                                setSelectedNode(data.startNode || Object.keys(data.nodes)[0]);
                                setFileName(config.scenario);
                                setLayoutLoaded(true);
                            });
                    })
                    .catch(() => setLayoutLoaded(true));
            }, []);
            
            const nodeIds = Object.keys(scenario.nodes);

            // Handler for updating node position from the map
            const handleUpdateNodePosition = (nodeId, position) => {
                setScenario(prev => ({
                    ...prev,
                    nodes: {
                        ...prev.nodes,
                        [nodeId]: {
                            ...prev.nodes[nodeId],
                            position: { x: Math.round(position.x), y: Math.round(position.y) }
                        }
                    }
                }));
                setHasChanges(true);
            };
            
            const handleLoad = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setFileName(file.name);
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        try {
                            const data = JSON.parse(ev.target.result);
                            // Assign stable _id to choices and resources
                            Object.keys(data.nodes).forEach(id => {
                                data.nodes[id].choices = ensureIds(data.nodes[id].choices);
                                data.nodes[id].resources = ensureIds(data.nodes[id].resources);
                            });
                            setScenario(data);
                            setSelectedNode(data.startNode || Object.keys(data.nodes)[0]);
                            setHasChanges(false);
                        } catch (err) { alert('Error: ' + err.message); }
                    };
                    reader.readAsText(file, 'UTF-8');
                }
                e.target.value = '';
            };
            
            // Collect warnings for incomplete choices/resources across all nodes
            const collectSaveWarnings = () => {
                const warnings = [];
                Object.keys(scenario.nodes).forEach(nodeId => {
                    const node = scenario.nodes[nodeId];
                    const nodeTitle = (node.content || '').match(/^#\s+(.+)$/m)?.[1] || nodeId;

                    (node.choices || []).forEach((choice, i) => {
                        const hasText = choice.text && choice.text.trim();
                        const hasTarget = !!choice.next;
                        if (!hasText && !hasTarget) {
                            warnings.push(`Node "${nodeTitle}": Choice ${i + 1} ‚Äî missing text and target`);
                        } else if (!hasText) {
                            warnings.push(`Node "${nodeTitle}": Choice ${i + 1} ‚Äî missing text`);
                        } else if (!hasTarget) {
                            warnings.push(`Node "${nodeTitle}": Choice ${i + 1} ‚Äî missing target`);
                        }
                    });

                    (node.resources || []).forEach((res, i) => {
                        const missing = [];
                        if (!res.type) missing.push('type');
                        if (!res.url || !res.url.trim()) missing.push('URL');
                        if (!res.label || !res.label.trim()) missing.push('label');
                        if (missing.length > 0) {
                            warnings.push(`Node "${nodeTitle}": Resource ${i + 1} ‚Äî missing ${missing.join(', ')}`);
                        }
                    });
                });
                return warnings;
            };

            // Execute the actual save (filter incomplete items, download JSON)
            const executeSave = () => {
                const { positions } = calculateAutoPositionsWithConfig(scenario.nodes, scenario.startNode);
                const nodesWithPositions = {};
                Object.keys(scenario.nodes).forEach(id => {
                    const node = scenario.nodes[id];
                    // Filter out incomplete choices and strip internal _id
                    const validChoices = (node.choices || [])
                        .filter(c => c.text && c.text.trim() && c.next)
                        .map(({ _id, ...rest }) => rest);
                    // Filter out incomplete resources and strip internal _id
                    const validResources = (node.resources || [])
                        .filter(r => r.type && r.url && r.url.trim() && r.label && r.label.trim())
                        .map(({ _id, ...rest }) => rest);
                    // Update position if it's a placeholder (0,0) or undefined
                    const pos = node.position;
                    if (!pos || (pos.x === 0 && pos.y === 0)) {
                        const autoPos = positions[id] || { x: 0, y: 0 };
                        nodesWithPositions[id] = { ...node, choices: validChoices, resources: validResources, position: { x: autoPos.x, y: autoPos.y } };
                    } else {
                        nodesWithPositions[id] = { ...node, choices: validChoices, resources: validResources };
                    }
                });
                const scenarioToSave = { ...scenario, nodes: nodesWithPositions };

                const saveName = fileName || 'scenario.json';
                const json = JSON.stringify(scenarioToSave, null, 4);
                const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = saveName; a.click();
                URL.revokeObjectURL(url);
                setHasChanges(false);
                setSaveWarnings(null);
            };

            const handleSave = () => {
                const warnings = collectSaveWarnings();
                if (warnings.length === 0) {
                    executeSave();
                } else {
                    setSaveWarnings(warnings);
                }
            };
            
            const handleNew = () => {
                if (hasChanges && !confirm('Unsaved changes will be lost. Continue?')) return;
                setScenario(createEmptyScenario());
                setSelectedNode('start');
                setFileName(null);
                setHasChanges(false);
            };
            
            const handleUpdateNode = (nodeId, node) => { setScenario(prev => ({ ...prev, nodes: { ...prev.nodes, [nodeId]: node } })); setHasChanges(true); };
            const handleCreateNode = (newId, newNode) => { setScenario(prev => ({ ...prev, nodes: { ...prev.nodes, [newId]: newNode } })); setHasChanges(true); };
            const handleDeleteNode = (nodeId) => {
                if (!confirm(`Delete "${nodeId}"?`)) return;
                const newNodes = { ...scenario.nodes }; delete newNodes[nodeId];
                Object.keys(newNodes).forEach(id => { if (newNodes[id].choices) newNodes[id].choices = newNodes[id].choices.filter(c => c.next !== nodeId); });
                setScenario(prev => ({ ...prev, nodes: newNodes }));
                setSelectedNode(Object.keys(newNodes)[0] || null);
                setHasChanges(true);
            };
            const handleRenameNode = (oldId, newId) => {
                const newNodes = {};
                Object.keys(scenario.nodes).forEach(id => {
                    const key = id === oldId ? newId : id;
                    newNodes[key] = { ...scenario.nodes[id] };
                    if (newNodes[key].choices) newNodes[key].choices = newNodes[key].choices.map(c => c.next === oldId ? { ...c, next: newId } : c);
                });
                setScenario(prev => ({ ...prev, startNode: prev.startNode === oldId ? newId : prev.startNode, nodes: newNodes }));
                setSelectedNode(newId);
                setHasChanges(true);
            };
            const handleUpdateMeta = (meta, trans) => { setScenario(prev => ({ ...prev, meta, translations: trans })); setHasChanges(true); };
            
            const triggerFileOpen = () => fileInputRef.current?.click();
            
            return (
                <div className="editor-container">
                    <button 
                        className={`sidebar-toggle ${!showSidebar ? 'collapsed' : ''}`}
                        onClick={() => setShowSidebar(!showSidebar)}
                        title={showSidebar ? 'Hide sidebar' : 'Show sidebar'}
                    >
                        {showSidebar ? '‚óÄ' : '‚ñ∂'}
                    </button>
                    <div className={`sidebar ${!showSidebar ? 'collapsed' : ''}`}>
                        <div className="sidebar-header">
                            <h1>Scenario Editor</h1>
                            <div className="sidebar-actions">
                                <button className="btn btn-success" onClick={handleNew}>New</button>
                                <button className="btn btn-secondary" onClick={triggerFileOpen}>Open</button>
                                <button className="btn btn-primary" onClick={handleSave}>Save</button>
                                <button className="btn btn-secondary" onClick={() => setShowMap(true)}>Map</button>
                            </div>
                            <input ref={fileInputRef} type="file" accept=".json" className="hidden-input" onChange={handleLoad} />
                        </div>
                        <NodeList scenario={scenario} selectedNode={selectedNode} onSelectNode={setSelectedNode} startNode={scenario.startNode} />
                    </div>
                    
                    <div className="main-editor">
                        <div className="editor-header">
                            <div>
                                <strong>{fileName || 'New scenario'}</strong>
                                {hasChanges && <span style={{ color: '#f59e0b', marginLeft: '0.5rem' }}>‚óè</span>}
                                <span style={{ marginLeft: '1rem', color: '#6b7280' }}>{nodeIds.length} nodes</span>
                            </div>
                            <button className="btn btn-secondary" onClick={() => setShowMetaEditor(true)}>‚öôÔ∏è Settings</button>
                        </div>
                        
                                                {selectedNode && scenario.nodes[selectedNode] ? (
                            <NodeEditor nodeId={selectedNode} node={scenario.nodes[selectedNode]} nodeIds={nodeIds} nodes={scenario.nodes} startNode={scenario.startNode} onUpdateNode={handleUpdateNode} onDeleteNode={handleDeleteNode} onRenameNode={handleRenameNode} onCreateNode={handleCreateNode} />
                        ) : (
                            <div className="empty-state"><h2>No node selected</h2><p>Select a node from the sidebar.</p></div>
                        )}
                        
                        <div className="status-bar">
                            <span className={hasChanges ? 'status-unsaved' : 'status-saved'}>{hasChanges ? '‚óè Unsaved' : '‚úì Saved'}</span>
                            <span>Start: {scenario.startNode}</span>
                        </div>
                    </div>
                    
                    {showMetaEditor && <MetaEditor meta={scenario.meta} translations={scenario.translations || {}} onUpdate={handleUpdateMeta} onClose={() => setShowMetaEditor(false)} />}

                    {saveWarnings && (
                        <div className="modal-overlay">
                            <div className="modal-content" style={{ maxWidth: '550px' }}>
                                <div className="modal-header">
                                    <h3>Incomplete items found</h3>
                                    <button className="btn btn-close" onClick={() => setSaveWarnings(null)} style={{ padding: '0.25rem 0.5rem' }}>‚úï</button>
                                </div>
                                <p style={{ color: '#6b7280', marginBottom: '1rem' }}>
                                    The following items are incomplete and will be removed from the saved file:
                                </p>
                                <ul style={{ listStyle: 'disc', paddingLeft: '1.5rem', marginBottom: '1.25rem', maxHeight: '300px', overflowY: 'auto' }}>
                                    {saveWarnings.map((w, i) => (
                                        <li key={i} style={{ color: '#b45309', fontSize: '0.85rem', marginBottom: '0.35rem' }}>{w}</li>
                                    ))}
                                </ul>
                                <div style={{ display: 'flex', gap: '0.5rem' }}>
                                    <button className="btn btn-primary" onClick={executeSave}>Save anyway</button>
                                    <button className="btn btn-danger" onClick={() => setSaveWarnings(null)}>Cancel</button>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {showMap && (
                        <TreeMapOverlay
                            nodes={scenario.nodes}
                            startNode={scenario.startNode}
                            selectedNode={selectedNode}
                            onSelectNode={setSelectedNode}
                            onClose={() => setShowMap(false)}
                            fileName={fileName}
                            onUpdateNodePosition={handleUpdateNodePosition}
                            translations={scenario.translations}
                        />
                    )}

                    <div className="credits">
                        Created by <a href="https://ai-know.pro" target="_blank" rel="noopener noreferrer">Paolo Dalprato</a>
                    </div>
                </div>
            );
        };
        
        ReactDOM.createRoot(document.getElementById('root')).render(
            <ErrorBoundary fallbackMessage="The Scenario Editor encountered an error. Please reload the page.">
                <ScenarioEditor />
            </ErrorBoundary>
        );
    </script>
</body>
</html>
