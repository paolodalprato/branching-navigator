<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scenario Editor - ChoiceMap</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="shared-styles.css">
    <style>
        /* Scenario Editor specific styles */
        .sidebar { width: 280px; }
        .node-list { flex: 1; overflow-y: auto; padding: 0.5rem; }
        .node-item { padding: 0.75rem; margin-bottom: 0.5rem; background: #ffffff; border-radius: 8px; cursor: pointer; border: 2px solid #e5e7eb; transition: all 0.2s; }
        .node-item:hover { border-color: #9ca3af; }
        .node-item.selected { border-color: #6366f1; background: #eef2ff; }
        .node-item.start-node { border-left: 3px solid #10b981; }
        .node-item.terminal { border-left: 3px solid #f59e0b; }
        .node-title { font-weight: 600; color: #111827; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .node-id-small { font-size: 0.7rem; color: #6b7280; font-family: monospace; margin-top: 0.15rem; }
        .node-badges { display: flex; gap: 0.25rem; margin-top: 0.5rem; flex-wrap: wrap; }
        .badge { font-size: 0.65rem; padding: 0.15rem 0.4rem; border-radius: 4px; background: #e5e7eb; color: #4b5563; }
        .badge-start { background: #d1fae5; color: #065f46; }
        .badge-terminal { background: #fef3c7; color: #92400e; }
        .main-editor { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .editor-header { padding: 1rem; background: #f9fafb; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center; }
        .lang-indicator { background: #e0e7ff; color: #4338ca; padding: 0.25rem 0.75rem; border-radius: 4px; font-size: 0.75rem; margin-left: 1rem; }
        .editor-content { flex: 1; overflow-y: auto; padding: 1.5rem; background: #ffffff; }
        .form-section { background: #f9fafb; border-radius: 8px; padding: 1.25rem; margin-bottom: 1.5rem; border: 1px solid #e5e7eb; }
        .form-section h3 { margin: 0 0 1rem 0; font-size: 1rem; color: #111827; display: flex; align-items: center; gap: 0.5rem; }
        .form-section .form-group { margin-bottom: 1rem; }
        .form-section .form-label { font-size: 0.8rem; margin-bottom: 0.4rem; }
        .form-section .form-input { padding: 0.6rem 0.75rem; font-size: 0.9rem; }
        .form-row { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
        .form-row.single { grid-template-columns: 1fr; }
        .choice-item, .resource-item { background: #ffffff; border-radius: 6px; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #e5e7eb; transition: border-color 0.2s, box-shadow 0.2s; }
        .choice-header, .resource-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem; }
        .choice-number { font-size: 0.8rem; color: #6366f1; font-weight: 600; }
        .form-section .form-select { padding: 0.6rem 0.75rem; font-size: 0.9rem; }
        .empty-state { text-align: center; padding: 3rem; color: #6b7280; }
        .empty-state h2 { color: #374151; margin-bottom: 0.5rem; }
        .map-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: #ffffff; z-index: 200; display: flex; flex-direction: column; }
        .map-overlay-header { display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.5rem; border-bottom: 1px solid #e5e7eb; background: #f9fafb; }
        .map-overlay-header h2 { margin: 0; color: #111827; font-size: 1.25rem; }
        .map-legend { display: flex; gap: 1.5rem; font-size: 0.8rem; color: #6b7280; }
        .map-legend span { display: flex; align-items: center; gap: 0.4rem; }
        .legend-dot { width: 12px; height: 12px; border-radius: 3px; border: 2px solid; }
        .legend-start { border-color: #10b981; background: #065f46; }
        .legend-terminal { border-color: #f59e0b; background: #78350f; }
        .legend-selected { border-color: #818cf8; background: #3730a3; }
        .legend-orphan { border-color: #ef4444; background: #7f1d1d; }
        .map-overlay-content { flex: 1; overflow: auto; display: flex; align-items: center; justify-content: center; padding: 2rem; }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // ============================================================
        // DEFAULT DATA (loaded from defaults.json)
        // ============================================================
        let layoutConfig = {
            levelHeight: 120,
            nodeWidth: 140,
            nodeHeight: 44,
            padding: 60
        };

        const defaultTranslations = {
            step: 'Step',
            restart: 'Start Over',
            endOfPath: 'End of this path',
            resources: 'Resources',
            viewMap: 'View Map',
            mapOf: 'Map of',
            back: 'Back',
            download: 'Download',
            openLink: 'Open',
            watchVideo: 'Watch'
        };
        
        // ============================================================
        // HELPER FUNCTIONS
        // ============================================================
        const calculateNodeLevels = (nodes, startNode) => {
            const levels = {};
            const visited = new Set();
            const queue = [{ id: startNode, level: 1 }];
            while (queue.length > 0) {
                const { id, level } = queue.shift();
                if (visited.has(id) || !nodes[id]) continue;
                visited.add(id);
                if (!levels[level]) levels[level] = [];
                levels[level].push(id);
                (nodes[id].choices || []).forEach(choice => {
                    if (choice.next && !visited.has(choice.next)) queue.push({ id: choice.next, level: level + 1 });
                });
            }
            Object.keys(nodes).forEach(id => { if (!visited.has(id)) { if (!levels[0]) levels[0] = []; levels[0].push(id); } });
            return levels;
        };
        
        const getNodeLevel = (nodeId, nodes, startNode) => {
            const levels = calculateNodeLevels(nodes, startNode);
            for (const [level, nodeIds] of Object.entries(levels)) {
                if (nodeIds.includes(nodeId)) return { level: parseInt(level), position: nodeIds.indexOf(nodeId) + 1 };
            }
            return { level: 0, position: 1 };
        };
        
        // ============================================================
        // TREE MAP OVERLAY COMPONENT
        // ============================================================
        const TreeMapOverlay = ({ nodes, startNode, selectedNode, onSelectNode, onClose, fileName }) => {
            const [selectedConnection, setSelectedConnection] = useState(null);
            const levels = calculateNodeLevels(nodes, startNode);
            const maxLevel = Math.max(...Object.keys(levels).map(Number), 1);
            const { levelHeight, nodeWidth, nodeHeight, padding } = layoutConfig;
            const positions = {};
            let maxWidth = 0;
            Object.entries(levels).forEach(([level, nodeIds]) => { maxWidth = Math.max(maxWidth, nodeIds.length * nodeWidth); });
            Object.entries(levels).forEach(([level, nodeIds]) => {
                const totalWidth = nodeIds.length * nodeWidth;
                const startX = (maxWidth - totalWidth) / 2 + nodeWidth / 2;
                nodeIds.forEach((nodeId, index) => { positions[nodeId] = { x: startX + index * nodeWidth + padding, y: parseInt(level) * levelHeight + padding }; });
            });
            
            // Build connections with metadata
            const connections = [];
            Object.entries(nodes).forEach(([nodeId, node]) => {
                if (node.choices && positions[nodeId]) {
                    node.choices.forEach((choice, idx) => { 
                        if (choice.next && positions[choice.next]) {
                            const fromPos = positions[nodeId];
                            const toPos = positions[choice.next];
                            const fromLevel = getNodeLevel(nodeId, nodes, startNode).level;
                            const toLevel = getNodeLevel(choice.next, nodes, startNode).level;
                            connections.push({ 
                                from: fromPos, 
                                to: toPos, 
                                fromId: nodeId, 
                                toId: choice.next,
                                fromLevel,
                                toLevel,
                                key: `${nodeId}-${choice.next}-${idx}`
                            }); 
                        }
                    });
                }
            });
            
            const isTerminal = (nodeId) => !nodes[nodeId]?.choices || nodes[nodeId].choices.length === 0;
            const isOrphan = (nodeId) => getNodeLevel(nodeId, nodes, startNode).level === 0;
            
            // Generate path for connection (straight line, arc for loops/same level)
            const getConnectionPath = (conn) => {
                const x1 = conn.from.x;
                const y1 = conn.from.y + nodeHeight / 2;
                const x2 = conn.to.x;
                const y2 = conn.to.y - nodeHeight / 2;

                // Forward connection (to lower level) - straight line
                if (conn.toLevel > conn.fromLevel) {
                    return { path: `M ${x1} ${y1} L ${x2} ${y2}`, type: 'line', x1, y1, x2, y2 };
                }

                // Same level or backward (loop) - curved arc
                const isBackward = conn.toLevel < conn.fromLevel;

                // Calculate control point for quadratic bezier
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;

                // Offset for the curve - more pronounced for backward connections
                let curveOffset;
                if (isBackward) {
                    const levelDiff = conn.fromLevel - conn.toLevel;
                    curveOffset = Math.max(80, levelDiff * 40 + 60);
                } else {
                    curveOffset = 50;
                }

                // Determine curve direction based on relative positions
                const curveDirection = x1 <= x2 ? 1 : -1;
                const controlX = midX + (curveOffset * curveDirection * (isBackward ? 1.5 : 1));
                const controlY = isBackward ? Math.min(y1, y2) - 30 : midY;

                return { path: `M ${x1} ${y1} Q ${controlX} ${controlY} ${x2} ${y2}`, type: 'bezier', x1, y1, x2, y2, cx: controlX, cy: controlY };
            };

            // Calculate midpoint and angle for arrow placement
            const getArrowPosition = (pathData) => {
                if (pathData.type === 'line') {
                    // Midpoint of straight line
                    const mx = (pathData.x1 + pathData.x2) / 2;
                    const my = (pathData.y1 + pathData.y2) / 2;
                    const angle = Math.atan2(pathData.y2 - pathData.y1, pathData.x2 - pathData.x1) * 180 / Math.PI;
                    return { x: mx, y: my, angle };
                } else {
                    // Midpoint of quadratic bezier at t=0.5
                    const t = 0.5;
                    const mx = (1-t)*(1-t)*pathData.x1 + 2*(1-t)*t*pathData.cx + t*t*pathData.x2;
                    const my = (1-t)*(1-t)*pathData.y1 + 2*(1-t)*t*pathData.cy + t*t*pathData.y2;
                    // Tangent at t=0.5: derivative of bezier
                    const tx = 2*(1-t)*(pathData.cx - pathData.x1) + 2*t*(pathData.x2 - pathData.cx);
                    const ty = 2*(1-t)*(pathData.cy - pathData.y1) + 2*t*(pathData.y2 - pathData.cy);
                    const angle = Math.atan2(ty, tx) * 180 / Math.PI;
                    return { x: mx, y: my, angle };
                }
            };
            
            // Get connection color based on type
            const getConnectionColor = (conn, isSelected, isHovered) => {
                if (isSelected || isHovered) return '#6366f1';
                if (conn.toLevel < conn.fromLevel) return '#f59e0b'; // backward/loop - amber
                if (conn.toLevel === conn.fromLevel) return '#8b5cf6'; // same level - purple
                return '#d1d5db'; // forward - gray
            };
            
            return (
                <div className="map-overlay">
                    <div className="map-overlay-header">
                        <h2>{fileName || 'Scenario Map'}</h2>
                        <div className="map-legend">
                            <span><span className="legend-dot legend-start"></span> Start</span>
                            <span><span className="legend-dot legend-terminal"></span> Terminal</span>
                            <span><span className="legend-dot legend-selected"></span> Selected</span>
                            <span><span className="legend-dot legend-orphan"></span> Orphan</span>
                        </div>
                        <button className="btn btn-close" onClick={onClose}>X</button>
                    </div>
                    <div className="map-overlay-content">
                        <svg width={Math.max(maxWidth + padding * 2 + 100, 400)} height={Math.max((maxLevel + 1) * levelHeight + padding, 300)} style={{ display: 'block', margin: 'auto' }}>
                            {/* Connections with midpoint arrows */}
                            {connections.map((conn) => {
                                const isSelected = selectedConnection === conn.key;
                                const pathData = getConnectionPath(conn);
                                const arrowPos = getArrowPosition(pathData);
                                const color = getConnectionColor(conn, isSelected, false);

                                return (
                                    <g key={conn.key}>
                                        {/* Invisible wider path for easier clicking */}
                                        <path
                                            d={pathData.path}
                                            fill="none"
                                            stroke="transparent"
                                            strokeWidth={15}
                                            style={{ cursor: 'pointer' }}
                                            onClick={() => setSelectedConnection(isSelected ? null : conn.key)}
                                        />
                                        {/* Visible path */}
                                        <path
                                            d={pathData.path}
                                            fill="none"
                                            stroke={color}
                                            strokeWidth={isSelected ? 3 : 2}
                                            style={{ cursor: 'pointer', transition: 'stroke 0.2s, stroke-width 0.2s' }}
                                            onClick={() => setSelectedConnection(isSelected ? null : conn.key)}
                                            onMouseEnter={(e) => {
                                                if (!isSelected) {
                                                    e.target.setAttribute('stroke', '#6366f1');
                                                    e.target.setAttribute('stroke-width', '3');
                                                    e.target.nextSibling?.setAttribute('fill', '#6366f1');
                                                }
                                            }}
                                            onMouseLeave={(e) => {
                                                if (!isSelected) {
                                                    e.target.setAttribute('stroke', getConnectionColor(conn, false, false));
                                                    e.target.setAttribute('stroke-width', '2');
                                                    e.target.nextSibling?.setAttribute('fill', getConnectionColor(conn, false, false));
                                                }
                                            }}
                                        />
                                        {/* Arrow at midpoint */}
                                        <polygon
                                            points="-10,-6 10,0 -10,6"
                                            fill={color}
                                            transform={`translate(${arrowPos.x}, ${arrowPos.y}) rotate(${arrowPos.angle})`}
                                            style={{ cursor: 'pointer', transition: 'fill 0.2s' }}
                                            onClick={() => setSelectedConnection(isSelected ? null : conn.key)}
                                        />
                                    </g>
                                );
                            })}
                            
                            {/* Nodes */}
                            {Object.entries(positions).map(([nodeId, pos]) => {
                                const isSelected = nodeId === selectedNode, isStart = nodeId === startNode, isEnd = isTerminal(nodeId), orphan = isOrphan(nodeId);
                                let fill = '#f3f4f6', stroke = '#9ca3af', sw = 2, textFill = '#374151';
                                if (isSelected) { fill = '#e0e7ff'; stroke = '#818cf8'; sw = 3; textFill = '#3730a3'; }
                                if (isStart) stroke = '#10b981'; else if (orphan) stroke = '#ef4444'; else if (isEnd) stroke = '#f59e0b';
                                const content = nodes[nodeId]?.content || '';
                                const title = content.match(/^#\s+(.+)$/m)?.[1]?.slice(0, 15) || nodeId;
                                return (
                                    <g key={nodeId} style={{ cursor: 'pointer' }} onClick={() => { onSelectNode(nodeId); onClose(); }}>
                                        <rect x={pos.x - nodeWidth/2 + 10} y={pos.y - nodeHeight/2} width={nodeWidth - 20} height={nodeHeight} rx={8} fill={fill} stroke={stroke} strokeWidth={sw} />
                                        <text x={pos.x} y={pos.y - 6} textAnchor="middle" dominantBaseline="middle" fill={textFill} fontSize="11" fontWeight="500">{title.length > 15 ? title.slice(0, 12) + '...' : title}</text>
                                        <text x={pos.x} y={pos.y + 10} textAnchor="middle" dominantBaseline="middle" fill="#6b7280" fontSize="9" fontFamily="monospace">{nodeId.length > 14 ? nodeId.slice(0, 12) + '..' : nodeId}</text>
                                    </g>
                                );
                            })}
                        </svg>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // SCENARIO FACTORY
        // ============================================================
        const createEmptyScenario = () => {
            return {
                meta: { title: 'New Scenario', description: '', author: '' },
                translations: { ...defaultTranslations },
                startNode: 'start',
                nodes: { start: { content: '# Welcome\n\nEdit this content.', choices: [], resources: [] } }
            };
        };
        
        // ============================================================
        // NODE LIST COMPONENT
        // ============================================================
        const NodeList = ({ scenario, selectedNode, onSelectNode, startNode }) => {
            const nodeIds = Object.keys(scenario.nodes);
            const getNodeTitle = (nodeId) => { const c = scenario.nodes[nodeId]?.content || ''; const m = c.match(/^#\s+(.+)$/m); return m ? m[1].replace(/\*\*/g, '').slice(0, 30) : 'Untitled'; };
            const isTerminal = (nodeId) => (scenario.nodes[nodeId]?.choices || []).length === 0;
            const getNodeLevelInfo = (nodeId) => { const info = getNodeLevel(nodeId, scenario.nodes, startNode); return info.level === 0 ? 'orphan' : `L${info.level}-P${info.position}`; };
            return (
                <div className="node-list">
                    {nodeIds.map(nodeId => (
                        <div key={nodeId} className={`node-item ${selectedNode === nodeId ? 'selected' : ''} ${nodeId === startNode ? 'start-node' : ''} ${isTerminal(nodeId) ? 'terminal' : ''}`} onClick={() => onSelectNode(nodeId)}>
                            <div className="node-title">{getNodeTitle(nodeId)}</div>
                            <div className="node-id-small">{nodeId}</div>
                            <div className="node-badges">
                                <span className="badge">{getNodeLevelInfo(nodeId)}</span>
                                {nodeId === startNode && <span className="badge badge-start">START</span>}
                                {isTerminal(nodeId) && <span className="badge badge-terminal">END</span>}
                            </div>
                        </div>
                    ))}
                </div>
            );
        };
        
    // ============================================================
    // CREATE NODE POPUP COMPONENT
    // ============================================================
    const CreateNodePopup = ({ parentNodeId, existingNodeIds, onCreateNode, onCreated, onClose }) => {
        const suggestId = () => { let base = `${parentNodeId}_child`, c = 1, id = base; while (existingNodeIds.includes(id)) { id = `${base}_${c}`; c++; } return id; };
        const [nodeId, setNodeId] = useState(suggestId());
        const [content, setContent] = useState('# New Node\\n\\nEdit this content.');
        const [errors, setErrors] = useState({ id: '', content: '' });

        const handleCreate = () => {
            const cleanId = nodeId.trim().replace(/[^a-zA-Z0-9_]/g, '_');
            const cleanContent = content.trim();
            const newErrors = { id: '', content: '' };
            let hasError = false;

            // Validate Node ID
            if (!cleanId) {
                newErrors.id = 'Node ID is required';
                hasError = true;
            } else if (existingNodeIds.includes(cleanId)) {
                newErrors.id = 'ID already exists';
                hasError = true;
            }

            // Validate Content
            if (!cleanContent) {
                newErrors.content = 'Node content is required';
                hasError = true;
            }

            setErrors(newErrors);

            if (hasError) return;

            onCreateNode(cleanId, { content: cleanContent, choices: [], resources: [] });
            onCreated(cleanId);
        };

        return (
            <div className="modal-overlay">
                <div className="modal-content">
                    <div className="modal-header"><h3>Create New Node</h3><button className="btn btn-close" onClick={onClose} style={{ padding: '0.25rem 0.5rem' }}>‚úï</button></div>
                    <div className="form-group">
                        <label className="form-label">
                            Node ID <span style={{ color: '#ef4444' }}>*</span>
                        </label>
                        <input
                            type="text"
                            className="form-input"
                            value={nodeId}
                            onChange={(e) => { setNodeId(e.target.value); setErrors(prev => ({ ...prev, id: '' })); }}
                            style={errors.id ? { borderColor: '#ef4444', boxShadow: '0 0 0 2px rgba(239, 68, 68, 0.2)' } : {}}
                        />
                        {errors.id && <div style={{ color: '#ef4444', fontSize: '0.75rem', marginTop: '0.35rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}><span>‚ö†Ô∏è</span> {errors.id}</div>}
                    </div>
                    <div className="form-group">
                        <label className="form-label">
                            Node content <span style={{ color: '#ef4444' }}>*</span>
                        </label>
                        <textarea
                            className="form-input"
                            rows={4}
                            value={content}
                            onChange={(e) => { setContent(e.target.value); setErrors(prev => ({ ...prev, content: '' })); }}
                            style={errors.content ? { borderColor: '#ef4444', boxShadow: '0 0 0 2px rgba(239, 68, 68, 0.2)' } : {}}
                        />
                        {errors.content && <div style={{ color: '#ef4444', fontSize: '0.75rem', marginTop: '0.35rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}><span>‚ö†Ô∏è</span> {errors.content}</div>}
                    </div>
                    <div style={{ display: 'flex', gap: '0.5rem', marginTop: '1rem' }}>
                        <button className="btn btn-success" onClick={handleCreate}>Create</button>
                        <button className="btn btn-danger" onClick={onClose}>CANCEL</button>
                    </div>
                </div>
            </div>
        );
    };
        
        // ============================================================
        // CHOICE EDITOR COMPONENT
        // ============================================================
        const ChoiceEditor = ({ choice, index, nodeIds, parentNodeId, onChange, onRemove, onCreateNode }) => {
            const [showCreate, setShowCreate] = useState(false);
            const [localText, setLocalText] = useState(choice.text || '');
            const [localTarget, setLocalTarget] = useState(choice.next || '');
            const [errors, setErrors] = useState({ text: null, target: null });
            const [pendingTarget, setPendingTarget] = useState(null);

            // Check if local values differ from saved values
            const hasUnsavedChanges = localText !== (choice.text || '') || localTarget !== (choice.next || '');
            const isComplete = (choice.text || '').trim() && (choice.next || '');

            // Sync local state when choice prop changes (e.g., after node creation)
            useEffect(() => {
                setLocalText(choice.text || '');
                setLocalTarget(choice.next || '');
            }, [choice.text, choice.next]);

            const handleTextChange = (e) => {
                setLocalText(e.target.value);
                if (e.target.value.trim()) {
                    setErrors(prev => ({ ...prev, text: null }));
                }
            };

            const handleTargetChange = (e) => {
                const newTarget = e.target.value;

                if (newTarget === '__CREATE__') {
                    // Store that we want to create a node, but need to save first
                    if (!localText.trim()) {
                        setErrors({ text: 'Button text required', target: null });
                        return;
                    }
                    setPendingTarget('__CREATE__');
                    setShowCreate(true);
                } else {
                    setLocalTarget(newTarget);
                    setPendingTarget(null);
                    if (newTarget) {
                        setErrors(prev => ({ ...prev, target: null }));
                    }
                }
            };

            const handleNodeCreated = (newNodeId) => {
                setLocalTarget(newNodeId);
                setPendingTarget(null);
                setShowCreate(false);
                // Auto-save after creating node since both fields are now complete
                if (localText.trim()) {
                    onChange({ ...choice, text: localText.trim(), next: newNodeId });
                    setErrors({ text: null, target: null });
                }
            };

            const handleSave = () => {
                const newErrors = { text: null, target: null };
                let hasError = false;

                if (!localText.trim()) {
                    newErrors.text = 'Button text is required';
                    hasError = true;
                }

                if (!localTarget) {
                    newErrors.target = 'Target node is required';
                    hasError = true;
                }

                setErrors(newErrors);

                if (!hasError) {
                    onChange({ ...choice, text: localText.trim(), next: localTarget });
                }
            };

            // Determine border style based on state
            const getBorderStyle = () => {
                if (errors.text || errors.target) return { borderColor: '#ef4444' };
                if (hasUnsavedChanges) return { borderColor: '#f59e0b', boxShadow: '0 0 0 2px rgba(245, 158, 11, 0.2)' };
                if (isComplete) return { borderColor: '#10b981' };
                return {};
            };

            return (
                <div className="choice-item" style={getBorderStyle()}>
                    <div className="choice-header">
                        <span className="choice-number">
                            Choice {index + 1}
                            {hasUnsavedChanges && <span style={{ color: '#f59e0b', marginLeft: '0.5rem', fontSize: '0.7rem' }}>‚óè unsaved</span>}
                            {isComplete && !hasUnsavedChanges && <span style={{ color: '#10b981', marginLeft: '0.5rem', fontSize: '0.7rem' }}>‚úì</span>}
                        </span>
                        <button className="btn btn-danger" onClick={onRemove} style={{ padding: '0.25rem 0.5rem', fontSize: '0.75rem' }}>REMOVE</button>
                    </div>
                    <div className="form-group">
                        <label className="form-label">
                            Button Text <span style={{ color: '#ef4444' }}>*</span>
                        </label>
                        <input
                            type="text"
                            className="form-input"
                            value={localText}
                            onChange={handleTextChange}
                            style={errors.text ? { borderColor: '#ef4444', boxShadow: '0 0 0 2px rgba(239, 68, 68, 0.2)' } : {}}
                            placeholder="Enter button text"
                        />
                        {errors.text && (
                            <div style={{ color: '#ef4444', fontSize: '0.75rem', marginTop: '0.35rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                <span>‚ö†Ô∏è</span> {errors.text}
                            </div>
                        )}
                    </div>
                    <div className="form-group">
                        <label className="form-label">
                            Target Node <span style={{ color: '#ef4444' }}>*</span>
                        </label>
                        <select
                            className="form-select"
                            value={localTarget}
                            onChange={handleTargetChange}
                            style={errors.target ? { borderColor: '#ef4444', boxShadow: '0 0 0 2px rgba(239, 68, 68, 0.2)' } : {}}
                        >
                            <option value="">-- Select target --</option>
                            <option value="__CREATE__" style={{ fontWeight: 'bold', color: '#10b981' }}>+ Create new node...</option>
                            {nodeIds.filter(id => id !== parentNodeId).map(id => <option key={id} value={id}>{id}</option>)}
                        </select>
                        {errors.target && (
                            <div style={{ color: '#ef4444', fontSize: '0.75rem', marginTop: '0.35rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                <span>‚ö†Ô∏è</span> {errors.target}
                            </div>
                        )}
                    </div>
                    <div style={{ marginTop: '0.75rem' }}>
                        <button className="btn btn-success" onClick={handleSave} style={{ width: '100%' }}>
                            Save Choice
                        </button>
                    </div>
                    {showCreate && <CreateNodePopup parentNodeId={parentNodeId} existingNodeIds={nodeIds} onCreateNode={onCreateNode} onCreated={handleNodeCreated} onClose={() => { setShowCreate(false); setPendingTarget(null); }} />}
                </div>
            );
        };
        
        // ============================================================
        // RESOURCE EDITOR COMPONENT
        // ============================================================
        const ResourceEditor = ({ resource, index, onChange, onRemove }) => {
            const [localType, setLocalType] = useState(resource.type || '');
            const [localUrl, setLocalUrl] = useState(resource.url || '');
            const [localLabel, setLocalLabel] = useState(resource.label || '');
            const [errors, setErrors] = useState({ type: null, url: null, label: null });

            // Check if local values differ from saved values
            const hasUnsavedChanges = localType !== (resource.type || '') || localUrl !== (resource.url || '') || localLabel !== (resource.label || '');
            const isComplete = (resource.type || '').trim() && (resource.url || '').trim() && (resource.label || '').trim();

            // Sync local state when resource prop changes
            useEffect(() => {
                setLocalType(resource.type || '');
                setLocalUrl(resource.url || '');
                setLocalLabel(resource.label || '');
            }, [resource.type, resource.url, resource.label]);

            const handleTypeChange = (e) => {
                setLocalType(e.target.value);
                if (e.target.value) {
                    setErrors(prev => ({ ...prev, type: null }));
                }
            };

            const handleUrlChange = (e) => {
                setLocalUrl(e.target.value);
                if (e.target.value.trim()) {
                    setErrors(prev => ({ ...prev, url: null }));
                }
            };

            const handleLabelChange = (e) => {
                setLocalLabel(e.target.value);
                if (e.target.value.trim()) {
                    setErrors(prev => ({ ...prev, label: null }));
                }
            };

            const handleSave = () => {
                const newErrors = { type: null, url: null, label: null };
                let hasError = false;

                if (!localType) {
                    newErrors.type = 'Type is required';
                    hasError = true;
                }

                if (!localUrl.trim()) {
                    newErrors.url = 'URL is required';
                    hasError = true;
                }

                if (!localLabel.trim()) {
                    newErrors.label = 'Label is required';
                    hasError = true;
                }

                setErrors(newErrors);

                if (!hasError) {
                    onChange({ ...resource, type: localType, url: localUrl.trim(), label: localLabel.trim() });
                }
            };

            // Determine border style based on state
            const getBorderStyle = () => {
                if (errors.type || errors.url || errors.label) return { borderColor: '#ef4444' };
                if (hasUnsavedChanges) return { borderColor: '#f59e0b', boxShadow: '0 0 0 2px rgba(245, 158, 11, 0.2)' };
                if (isComplete) return { borderColor: '#10b981' };
                return {};
            };

            return (
                <div className="resource-item" style={getBorderStyle()}>
                    <div className="resource-header">
                        <span className="choice-number">
                            Resource {index + 1}
                            {hasUnsavedChanges && <span style={{ color: '#f59e0b', marginLeft: '0.5rem', fontSize: '0.7rem' }}>‚óè unsaved</span>}
                            {isComplete && !hasUnsavedChanges && <span style={{ color: '#10b981', marginLeft: '0.5rem', fontSize: '0.7rem' }}>‚úì</span>}
                        </span>
                        <button className="btn btn-danger" onClick={onRemove} style={{ padding: '0.25rem 0.5rem', fontSize: '0.75rem' }}>REMOVE</button>
                    </div>
                    <div className="form-row">
                        <div className="form-group">
                            <label className="form-label">
                                Type <span style={{ color: '#ef4444' }}>*</span>
                            </label>
                            <select
                                className="form-select"
                                value={localType}
                                onChange={handleTypeChange}
                                style={errors.type ? { borderColor: '#ef4444', boxShadow: '0 0 0 2px rgba(239, 68, 68, 0.2)' } : {}}
                            >
                                <option value="">-- Select type --</option>
                                <option value="link">Link</option>
                                <option value="download">Download</option>
                                <option value="video">Video</option>
                            </select>
                            {errors.type && (
                                <div style={{ color: '#ef4444', fontSize: '0.75rem', marginTop: '0.35rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                    <span>‚ö†Ô∏è</span> {errors.type}
                                </div>
                            )}
                        </div>
                        <div className="form-group">
                            <label className="form-label">
                                URL <span style={{ color: '#ef4444' }}>*</span>
                            </label>
                            <input
                                type="text"
                                className="form-input"
                                value={localUrl}
                                onChange={handleUrlChange}
                                style={errors.url ? { borderColor: '#ef4444', boxShadow: '0 0 0 2px rgba(239, 68, 68, 0.2)' } : {}}
                                placeholder="https://..."
                            />
                            {errors.url && (
                                <div style={{ color: '#ef4444', fontSize: '0.75rem', marginTop: '0.35rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                    <span>‚ö†Ô∏è</span> {errors.url}
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="form-group">
                        <label className="form-label">
                            Label <span style={{ color: '#ef4444' }}>*</span>
                        </label>
                        <input
                            type="text"
                            className="form-input"
                            value={localLabel}
                            onChange={handleLabelChange}
                            style={errors.label ? { borderColor: '#ef4444', boxShadow: '0 0 0 2px rgba(239, 68, 68, 0.2)' } : {}}
                            placeholder="Resource description"
                        />
                        {errors.label && (
                            <div style={{ color: '#ef4444', fontSize: '0.75rem', marginTop: '0.35rem', display: 'flex', alignItems: 'center', gap: '0.25rem' }}>
                                <span>‚ö†Ô∏è</span> {errors.label}
                            </div>
                        )}
                    </div>
                    <div style={{ marginTop: '0.75rem' }}>
                        <button className="btn btn-success" onClick={handleSave} style={{ width: '100%' }}>
                            Save Resource
                        </button>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // NODE EDITOR COMPONENT
        // ============================================================
        const NodeEditor = ({ nodeId, node, nodeIds, startNode, onUpdateNode, onDeleteNode, onRenameNode, onCreateNode }) => {
            const [newNodeId, setNewNodeId] = useState(nodeId);
            const [showRename, setShowRename] = useState(false);

            useEffect(() => { setNewNodeId(nodeId); setShowRename(false); }, [nodeId]);

            const handleRename = () => { if (newNodeId && newNodeId !== nodeId && !nodeIds.includes(newNodeId)) { onRenameNode(nodeId, newNodeId); setShowRename(false); } };
            const updateContent = (value) => onUpdateNode(nodeId, { ...node, content: value });
            const updateChoice = (i, c) => { const nc = [...(node.choices || [])]; nc[i] = c; onUpdateNode(nodeId, { ...node, choices: nc }); };
            const addChoice = () => onUpdateNode(nodeId, { ...node, choices: [...(node.choices || []), { text: '', next: '' }] });
            const removeChoice = (i) => onUpdateNode(nodeId, { ...node, choices: (node.choices || []).filter((_, idx) => idx !== i) });
            const updateResource = (i, r) => { const nr = [...(node.resources || [])]; nr[i] = r; onUpdateNode(nodeId, { ...node, resources: nr }); };
            const addResource = () => onUpdateNode(nodeId, { ...node, resources: [...(node.resources || []), { type: 'link', label: '', url: '' }] });
            const removeResource = (i) => onUpdateNode(nodeId, { ...node, resources: (node.resources || []).filter((_, idx) => idx !== i) });

            return (
                <div className="editor-content">
                    <div className="form-section">
                        <h3>Node: {nodeId} {nodeId === startNode && <span className="badge badge-start" style={{ marginLeft: '0.5rem' }}>START</span>}</h3>
                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                            {!showRename ? <button className="btn btn-secondary" onClick={() => setShowRename(true)}>Rename</button> : (
                                <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                    <input type="text" className="form-input" style={{ width: '150px' }} value={newNodeId} onChange={(e) => setNewNodeId(e.target.value.replace(/[^a-zA-Z0-9_]/g, ''))} />
                                    <button className="btn btn-primary" onClick={handleRename}>OK</button>
                                    <button className="btn btn-danger" onClick={() => { setShowRename(false); setNewNodeId(nodeId); }}>Cancel</button>
                                </div>
                            )}
                            {nodeId !== startNode && <button className="btn btn-danger" onClick={() => onDeleteNode(nodeId)}>Delete</button>}
                        </div>
                    </div>

                    <div className="form-section">
                        <h3>üìù Content</h3>
                        <div className="form-group">
                            <label className="form-label">Content - Markdown</label>
                            <textarea className="form-input form-textarea" value={node.content || ''} onChange={(e) => updateContent(e.target.value)} placeholder="# Title&#10;&#10;Content..." />
                        </div>
                    </div>

                    <div className="form-section">
                        <h3>üîÄ Choices ({(node.choices || []).length})</h3>
                        {(node.choices || []).map((choice, i) => <ChoiceEditor key={i} choice={choice} index={i} nodeIds={nodeIds} parentNodeId={nodeId} onChange={(c) => updateChoice(i, c)} onRemove={() => removeChoice(i)} onCreateNode={onCreateNode} />)}
                        <button className="btn btn-success" onClick={addChoice}>+ Add Choice</button>
                        {(node.choices || []).length === 0 && <p style={{ fontSize: '0.8rem', color: '#9ca3af', marginTop: '0.5rem', textAlign: 'center' }}>No choices = terminal node</p>}
                    </div>

                    <div className="form-section">
                        <h3>üìé Resources ({(node.resources || []).length})</h3>
                        {(node.resources || []).map((r, i) => <ResourceEditor key={i} resource={r} index={i} onChange={(res) => updateResource(i, res)} onRemove={() => removeResource(i)} />)}
                        <button className="btn btn-success" onClick={addResource}>+ Add Resource</button>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // META EDITOR COMPONENT
        // ============================================================
        const MetaEditor = ({ meta, translations, onUpdate, onClose }) => {
            const [localMeta, setLocalMeta] = useState(meta);
            const [localTrans, setLocalTrans] = useState(translations);
            const handleSave = () => { onUpdate(localMeta, localTrans); onClose(); };
            return (
                <div className="modal-overlay">
                    <div className="modal-content" style={{ maxWidth: '650px' }}>
                        <div className="modal-header"><h2>Scenario Settings</h2><button className="btn btn-close" onClick={onClose}>‚úï</button></div>
                        <div className="form-group">
                            <label className="form-label">Title</label>
                            <input type="text" className="form-input" value={localMeta.title || ''} onChange={(e) => setLocalMeta({ ...localMeta, title: e.target.value })} />
                        </div>
                        <div className="form-group">
                            <label className="form-label">Description</label>
                            <textarea className="form-input" rows={2} value={localMeta.description || ''} onChange={(e) => setLocalMeta({ ...localMeta, description: e.target.value })} />
                        </div>
                        <div className="form-group">
                            <label className="form-label">Author</label>
                            <input type="text" className="form-input" value={localMeta.author || ''} onChange={(e) => setLocalMeta({ ...localMeta, author: e.target.value })} />
                        </div>
                        <hr style={{ borderColor: '#374151', margin: '1rem 0' }} />
                        <h4 style={{ color: '#111827', marginBottom: '0.75rem' }}>UI Labels</h4>
                        <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.5rem' }}>
                            {Object.keys(defaultTranslations).map(key => (
                                <div key={key} className="form-group" style={{ marginBottom: '0.5rem' }}>
                                    <label className="form-label" style={{ fontSize: '0.7rem' }}>{key}</label>
                                    <input type="text" className="form-input" style={{ padding: '0.4rem', fontSize: '0.8rem' }} value={localTrans?.[key] || ''} onChange={(e) => setLocalTrans({ ...localTrans, [key]: e.target.value })} />
                                </div>
                            ))}
                        </div>
                        <div style={{ display: 'flex', gap: '0.5rem', marginTop: '1rem' }}>
                            <button className="btn btn-primary" onClick={handleSave}>Save</button>
                            <button className="btn btn-danger" onClick={onClose}>Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // MAIN SCENARIO EDITOR COMPONENT
        // ============================================================
        const ScenarioEditor = () => {
            // Initialize with empty scenario directly (no welcome screen)
            const [scenario, setScenario] = useState(() => createEmptyScenario());
            const [selectedNode, setSelectedNode] = useState('start');
            const [hasChanges, setHasChanges] = useState(false);
            const [showMetaEditor, setShowMetaEditor] = useState(false);
            const [showMap, setShowMap] = useState(false);
            const [fileName, setFileName] = useState(null);
            const [layoutLoaded, setLayoutLoaded] = useState(false);
            const fileInputRef = useRef(null);

            // Load layout configuration from defaults.json
            useEffect(() => {
                fetch('defaults.json?v=' + Date.now())
                    .then(res => res.ok ? res.json() : null)
                    .then(data => {
                        if (data?.layout) {
                            layoutConfig = { ...layoutConfig, ...data.layout };
                        }
                        setLayoutLoaded(true);
                    })
                    .catch(() => setLayoutLoaded(true));
            }, []);
            
            const nodeIds = Object.keys(scenario.nodes);
            
            const handleLoad = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setFileName(file.name);
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        try {
                            const data = JSON.parse(ev.target.result);
                            setScenario(data);
                            setSelectedNode(data.startNode || Object.keys(data.nodes)[0]);
                            setHasChanges(false);
                        } catch (err) { alert('Error: ' + err.message); }
                    };
                    reader.readAsText(file, 'UTF-8');
                }
                e.target.value = '';
            };
            
            const handleSave = () => {
                const saveName = fileName || 'scenario.json';
                const json = JSON.stringify(scenario, null, 4);
                const blob = new Blob([json], { type: 'application/json;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = saveName; a.click();
                URL.revokeObjectURL(url);
                setHasChanges(false);
            };
            
            const handleNew = () => {
                if (hasChanges && !confirm('Unsaved changes will be lost. Continue?')) return;
                setScenario(createEmptyScenario());
                setSelectedNode('start');
                setFileName(null);
                setHasChanges(false);
            };
            
            const handleUpdateNode = (nodeId, node) => { setScenario(prev => ({ ...prev, nodes: { ...prev.nodes, [nodeId]: node } })); setHasChanges(true); };
            const handleCreateNode = (newId, newNode) => { setScenario(prev => ({ ...prev, nodes: { ...prev.nodes, [newId]: newNode } })); setHasChanges(true); };
            const handleDeleteNode = (nodeId) => {
                if (!confirm(`Delete "${nodeId}"?`)) return;
                const newNodes = { ...scenario.nodes }; delete newNodes[nodeId];
                Object.keys(newNodes).forEach(id => { if (newNodes[id].choices) newNodes[id].choices = newNodes[id].choices.filter(c => c.next !== nodeId); });
                setScenario(prev => ({ ...prev, nodes: newNodes }));
                setSelectedNode(Object.keys(newNodes)[0] || null);
                setHasChanges(true);
            };
            const handleRenameNode = (oldId, newId) => {
                const newNodes = {};
                Object.keys(scenario.nodes).forEach(id => {
                    const key = id === oldId ? newId : id;
                    newNodes[key] = { ...scenario.nodes[id] };
                    if (newNodes[key].choices) newNodes[key].choices = newNodes[key].choices.map(c => c.next === oldId ? { ...c, next: newId } : c);
                });
                setScenario(prev => ({ ...prev, startNode: prev.startNode === oldId ? newId : prev.startNode, nodes: newNodes }));
                setSelectedNode(newId);
                setHasChanges(true);
            };
            const handleUpdateMeta = (meta, trans) => { setScenario(prev => ({ ...prev, meta, translations: trans })); setHasChanges(true); };
            
            const triggerFileOpen = () => fileInputRef.current?.click();
            
            return (
                <div className="editor-container">
                    <div className="sidebar">
                        <div className="sidebar-header">
                            <h1>Scenario Editor</h1>
                            <div className="sidebar-actions">
                                <button className="btn btn-success" onClick={handleNew}>New</button>
                                <button className="btn btn-secondary" onClick={triggerFileOpen}>Open</button>
                                <button className="btn btn-primary" onClick={handleSave}>Save</button>
                                <button className="btn btn-secondary" onClick={() => setShowMap(true)}>Map</button>
                            </div>
                            <input ref={fileInputRef} type="file" accept=".json" className="hidden-input" onChange={handleLoad} />
                        </div>
                        <NodeList scenario={scenario} selectedNode={selectedNode} onSelectNode={setSelectedNode} startNode={scenario.startNode} />
                    </div>
                    
                    <div className="main-editor">
                        <div className="editor-header">
                            <div>
                                <strong>{fileName || 'New scenario'}</strong>
                                {hasChanges && <span style={{ color: '#f59e0b', marginLeft: '0.5rem' }}>‚óè</span>}
                                <span style={{ marginLeft: '1rem', color: '#6b7280' }}>{nodeIds.length} nodes</span>
                            </div>
                            <button className="btn btn-secondary" onClick={() => setShowMetaEditor(true)}>‚öôÔ∏è Settings</button>
                        </div>
                        
                        {selectedNode && scenario.nodes[selectedNode] ? (
                            <NodeEditor nodeId={selectedNode} node={scenario.nodes[selectedNode]} nodeIds={nodeIds} startNode={scenario.startNode} onUpdateNode={handleUpdateNode} onDeleteNode={handleDeleteNode} onRenameNode={handleRenameNode} onCreateNode={handleCreateNode} />
                        ) : (
                            <div className="empty-state"><h2>No node selected</h2><p>Select a node from the sidebar.</p></div>
                        )}
                        
                        <div className="status-bar">
                            <span className={hasChanges ? 'status-unsaved' : 'status-saved'}>{hasChanges ? '‚óè Unsaved' : '‚úì Saved'}</span>
                            <span>Start: {scenario.startNode}</span>
                        </div>
                    </div>
                    
                    {showMetaEditor && <MetaEditor meta={scenario.meta} translations={scenario.translations || {}} onUpdate={handleUpdateMeta} onClose={() => setShowMetaEditor(false)} />}
                    
                    {showMap && <TreeMapOverlay nodes={scenario.nodes} startNode={scenario.startNode} selectedNode={selectedNode} onSelectNode={setSelectedNode} onClose={() => setShowMap(false)} fileName={fileName} />}

                    <div className="credits">
                        Created by <a href="https://ai-know.pro" target="_blank" rel="noopener noreferrer">Paolo Dalprato</a>
                    </div>
                </div>
            );
        };
        
        ReactDOM.createRoot(document.getElementById('root')).render(<ScenarioEditor />);
    </script>
</body>
</html>
