<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChoiceMap - Interactive Decision Tree</title>
    <meta name="description" content="ChoiceMap: A framework for documenting multi-choice processes through interactive decision trees">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { box-sizing: border-box; }
        body { margin: 0; padding: 0; font-family: var(--font-family, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif); background: var(--bg); min-height: 100vh; overflow-x: hidden; }
        .slide-container { min-height: 100vh; display: flex; flex-direction: column; }
        .slide-content { flex: 1; display: flex; flex-direction: column; justify-content: center; padding: 2rem; max-width: 900px; margin: 0 auto; width: 100%; }
        .slide-content h1 { color: var(--text); font-size: 2.5rem; margin-bottom: 1.5rem; font-weight: 600; }
        .slide-content h2 { color: var(--text); font-size: 1.5rem; margin-bottom: 1rem; font-weight: 500; }
        .slide-content p { color: var(--text-secondary); font-size: 1.125rem; line-height: 1.7; margin-bottom: 1rem; }
        .slide-content ul { color: var(--text-secondary); font-size: 1.125rem; line-height: 1.7; margin-bottom: 1rem; padding-left: 1.5rem; }
        .slide-content li { margin-bottom: 0.5rem; }
        .slide-content blockquote { border-left: 4px solid var(--accent); padding: 1rem; margin: 1.5rem 0; color: var(--text-secondary); font-style: italic; background: color-mix(in srgb, var(--accent) 8%, transparent); border-radius: 0 8px 8px 0; }
        .slide-content strong { color: var(--text); font-weight: 600; }
        .slide-content em { color: var(--text-secondary); }
        .choices-container { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 2rem; justify-content: flex-start; }
        .choice-button { background: var(--choice-bg); color: var(--choice-text); border: none; padding: 1rem 1.5rem; border-radius: 12px; font-size: 1rem; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px color-mix(in srgb, var(--choice-bg) 30%, transparent); min-width: 180px; text-align: center; }
        .choice-button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px color-mix(in srgb, var(--choice-bg) 40%, transparent); }
        .choice-button.visited { background: var(--visited-bg); color: var(--visited-text); }
        .choice-button.visited::after { content: ' ‚úì'; }
        .choice-button.explored { background: var(--explored-bg); color: var(--explored-text); border: 2px solid var(--accent); }
        .header-bar { display: flex; justify-content: space-between; align-items: center; padding: 1rem; width: 100%; }
        .scenario-title { color: var(--text); font-size: 1rem; font-weight: 500; max-width: 50%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .brand-header { display: flex; align-items: center; gap: 0.75rem; }
        .progress-indicator { color: var(--text-muted); font-size: 0.875rem; padding: 1rem; }
        .map-button { position: fixed; bottom: 1rem; right: 1rem; background: color-mix(in srgb, var(--accent) 10%, transparent); border: 1px solid var(--accent); color: var(--accent-hover); padding: 0.75rem 1.25rem; border-radius: 8px; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 0.5rem; z-index: 100; }
        .map-button:hover { background: color-mix(in srgb, var(--accent) 20%, transparent); }
        .restart-button { background: var(--restart-bg); color: var(--restart-text); border: none; padding: 1rem 2rem; border-radius: 12px; font-size: 1rem; cursor: pointer; transition: all 0.3s ease; margin-top: 1rem; }
        .restart-button:hover { transform: translateY(-2px); }
        .terminal-badge { display: inline-block; background: var(--success); color: white; padding: 0.5rem 1rem; border-radius: 20px; font-size: 0.875rem; margin-bottom: 1rem; }
        .back-button { position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); background: var(--bg); border: 1px solid var(--border); color: var(--text-secondary); padding: 0.5rem 1.25rem; border-radius: 20px; cursor: pointer; transition: all 0.3s ease; font-size: 0.875rem; display: flex; align-items: center; gap: 0.5rem; z-index: 50; }
        .back-button:hover { background: color-mix(in srgb, var(--accent) 10%, transparent); border-color: var(--accent); color: var(--accent-hover); }
        .back-button svg { width: 16px; height: 16px; }
        .resources-section { margin-top: 2rem; padding-top: 1.5rem; border-top: 1px solid var(--border); }
        .resources-title { color: var(--text-muted); font-size: 0.875rem; margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 0.05em; }
        .resource-link { display: inline-flex; align-items: center; gap: 0.5rem; color: var(--accent-hover); text-decoration: none; padding: 0.5rem 1rem; background: color-mix(in srgb, var(--accent) 8%, transparent); border-radius: 6px; margin-right: 0.75rem; margin-bottom: 0.75rem; transition: all 0.3s ease; }
        .resource-link:hover { background: color-mix(in srgb, var(--accent) 15%, transparent); }
        .map-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg); z-index: 200; display: flex; flex-direction: column; }
        .map-header { display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.5rem; border-bottom: 1px solid var(--border); }
        .map-header h2 { color: var(--text); font-size: 1.25rem; margin: 0; flex: 1; }
        .map-toolbar { display: flex; gap: 0.5rem; align-items: center; }
        .map-toolbar button { padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.875rem; transition: all 0.2s; }
        .btn-secondary { background: color-mix(in srgb, var(--accent) 10%, transparent); border: 1px solid var(--accent); color: var(--accent-hover); }
        .btn-secondary:hover { background: color-mix(in srgb, var(--accent) 20%, transparent); }
        .close-button { background: #ef4444; border: none; color: white; cursor: pointer; padding: 0.5rem 1rem; border-radius: 6px; font-size: 1rem; font-weight: 600; }
        .close-button:hover { background: #dc2626; }
        .map-content { flex: 1; overflow: auto; display: flex; align-items: center; justify-content: center; padding: 2rem; }
        .map-footer { padding: 0.75rem 1.5rem; border-top: 1px solid var(--border); font-size: 0.8rem; color: var(--text-muted); }
        .tree-node { cursor: pointer; transition: all 0.3s ease; }
        .tree-node:hover { filter: brightness(1.2); }
        .tree-node.visited { cursor: pointer; }
        .tree-node.not-visited { opacity: 0.7; cursor: default; }
        .tree-node.current { filter: brightness(1.1); }
        .tree-node.dragging { cursor: grabbing; opacity: 0.8; }
        .loading { display: flex; justify-content: center; align-items: center; min-height: 100vh; color: var(--text-secondary); font-size: 1.25rem; }
        .error { display: flex; justify-content: center; align-items: center; min-height: 100vh; color: #ef4444; font-size: 1.25rem; flex-direction: column; gap: 1rem; }
        .brand-logo { height: 32px; width: auto; }
        .brand-name { color: var(--text); font-size: 0.9rem; font-weight: 500; }
        .brand-name a { color: inherit; text-decoration: none; }
        .brand-name a:hover { color: var(--accent); }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        let fontOptions = {};
        let defaultTheme = {};
        let layoutConfig = { levelHeight: 120, nodeWidth: 140, nodeHeight: 40, padding: 60 };

        const loadGoogleFont = (fontKey) => {
            const font = fontOptions[fontKey];
            if (!font || !font.google) return;
            const fontName = font.name.replace(/ /g, '+');
            let link = document.getElementById('google-font-link');
            if (!link) { link = document.createElement('link'); link.id = 'google-font-link'; link.rel = 'stylesheet'; document.head.appendChild(link); }
            link.href = `https://fonts.googleapis.com/css2?family=${fontName}:wght@400;500;600;700&display=swap`;
        };

        const applyTheme = (theme) => {
            const root = document.documentElement;
            const t = { ...defaultTheme, ...theme };
            const c = { ...defaultTheme.colors, ...t.colors };
            const b = { ...defaultTheme.buttons, ...t.buttons };
            const m = { ...defaultTheme.map, ...t.map };
            const typ = { ...defaultTheme.typography, ...t.typography };
            const fontKey = typ.fontFamily || 'system';
            const font = fontOptions[fontKey] || fontOptions['system'];
            loadGoogleFont(fontKey);
            root.style.setProperty('--font-family', font?.family || 'system-ui');
            root.style.setProperty('--bg', c.background);
            root.style.setProperty('--text', c.text);
            root.style.setProperty('--text-secondary', c.textSecondary);
            root.style.setProperty('--text-muted', c.textMuted);
            root.style.setProperty('--accent', c.accent);
            root.style.setProperty('--accent-hover', c.accentHover);
            root.style.setProperty('--success', c.success);
            root.style.setProperty('--warning', c.warning);
            root.style.setProperty('--border', c.border);
            root.style.setProperty('--choice-bg', b.choiceBackground);
            root.style.setProperty('--choice-text', b.choiceText);
            root.style.setProperty('--visited-bg', b.visitedBackground);
            root.style.setProperty('--visited-text', b.visitedText);
            root.style.setProperty('--explored-bg', b.exploredBackground);
            root.style.setProperty('--explored-text', b.exploredText);
            root.style.setProperty('--restart-bg', b.restartBackground);
            root.style.setProperty('--restart-text', b.restartText);
            root.style.setProperty('--map-node-visited', m.nodeVisited);
            root.style.setProperty('--map-node-visited-text', m.nodeVisitedText);
            root.style.setProperty('--map-node-current', m.nodeCurrent);
            root.style.setProperty('--map-node-current-text', m.nodeCurrentText);
            root.style.setProperty('--map-node-unvisited', m.nodeUnvisited);
            root.style.setProperty('--map-node-unvisited-text', m.nodeUnvisitedText);
            root.style.setProperty('--map-node-unvisited-border', m.nodeUnvisitedBorder);
            root.style.setProperty('--map-line-visited', m.lineVisited);
            root.style.setProperty('--map-line-unvisited', m.lineUnvisited);
        };

        const getText = (value) => {
            if (typeof value === 'string') return value;
            if (value && typeof value === 'object') return value[Object.keys(value)[0]] || '';
            return '';
        };

        const calculateNodeLevels = (nodes, startNode) => {
            const levels = {};
            const visited = new Set();
            const queue = [{ id: startNode, level: 0 }];
            while (queue.length > 0) {
                const { id, level } = queue.shift();
                if (visited.has(id) || !nodes[id]) continue;
                visited.add(id);
                if (!levels[level]) levels[level] = [];
                levels[level].push(id);
                (nodes[id].choices || []).forEach(choice => {
                    if (choice.next && !visited.has(choice.next)) queue.push({ id: choice.next, level: level + 1 });
                });
            }
            return levels;
        };

        const calculateAutoPositions = (nodes, startNode) => {
            const levels = calculateNodeLevels(nodes, startNode);
            const { levelHeight, nodeWidth, padding } = layoutConfig;
            const positions = {};
            let maxWidth = 0;
            Object.entries(levels).forEach(([level, nodeIds]) => { maxWidth = Math.max(maxWidth, nodeIds.length * nodeWidth); });
            Object.entries(levels).forEach(([level, nodeIds]) => {
                const totalWidth = nodeIds.length * nodeWidth;
                const startX = (maxWidth - totalWidth) / 2 + nodeWidth / 2;
                nodeIds.forEach((nodeId, index) => { positions[nodeId] = { x: startX + index * nodeWidth + padding, y: parseInt(level) * levelHeight + padding }; });
            });
            return { positions, maxWidth, maxLevel: Math.max(...Object.keys(levels).map(Number), 0) };
        };

        const MarkdownContent = ({ content }) => {
            const parseMarkdown = (text) => {
                if (!text) return [];
                const lines = text.split('\n');
                const elements = [];
                let currentList = [];
                const processInline = (line) => line.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>').replace(/\*(.+?)\*/g, '<em>$1</em>');
                const flushList = () => { if (currentList.length > 0) { elements.push(<ul key={`list-${elements.length}`}>{currentList.map((item, i) => <li key={i} dangerouslySetInnerHTML={{ __html: processInline(item) }} />)}</ul>); currentList = []; } };
                lines.forEach((line, index) => {
                    if (line.startsWith('# ')) { flushList(); elements.push(<h1 key={index} dangerouslySetInnerHTML={{ __html: processInline(line.slice(2)) }} />); }
                    else if (line.startsWith('## ')) { flushList(); elements.push(<h2 key={index} dangerouslySetInnerHTML={{ __html: processInline(line.slice(3)) }} />); }
                    else if (line.startsWith('> ')) { flushList(); elements.push(<blockquote key={index} dangerouslySetInnerHTML={{ __html: processInline(line.slice(2)) }} />); }
                    else if (line.startsWith('- ')) { currentList.push(line.slice(2)); }
                    else if (line.trim()) { flushList(); elements.push(<p key={index} dangerouslySetInnerHTML={{ __html: processInline(line) }} />); }
                    else { flushList(); }
                });
                flushList();
                return elements;
            };
            return <>{parseMarkdown(content)}</>;
        };

        const TreeMap = ({ scenarioData, nodes, visitedNodes, currentNode, onNodeClick, onClose, translations }) => {
            const [draggingNode, setDraggingNode] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [nodePositions, setNodePositions] = useState({});
            const [svgSize, setSvgSize] = useState({ width: 800, height: 600 });
            const svgRef = useRef(null);
            const { nodeWidth, nodeHeight, padding } = layoutConfig;

            useEffect(() => {
                const autoLayout = calculateAutoPositions(nodes, scenarioData.startNode);
                const positions = {};
                Object.keys(nodes).forEach(nodeId => {
                    positions[nodeId] = nodes[nodeId].position ? { ...nodes[nodeId].position } : (autoLayout.positions[nodeId] || { x: padding, y: padding });
                });
                setNodePositions(positions);
                const allX = Object.values(positions).map(p => p.x);
                const allY = Object.values(positions).map(p => p.y);
                setSvgSize({ width: Math.max(...allX, 400) + nodeWidth + padding, height: Math.max(...allY, 300) + nodeHeight + padding });
            }, [nodes, scenarioData.startNode]);

            // CTRL+drag to move nodes
            const handleMouseDown = (e, nodeId) => {
                if (e.button !== 0) return;
                if (!e.ctrlKey && !e.metaKey) return;
                
                e.stopPropagation();
                e.preventDefault();
                
                const svg = svgRef.current;
                const pt = svg.createSVGPoint();
                pt.x = e.clientX; pt.y = e.clientY;
                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                setDragOffset({ x: svgP.x - nodePositions[nodeId].x, y: svgP.y - nodePositions[nodeId].y });
                setDraggingNode(nodeId);
            };

            // Click (without CTRL) to navigate to visited node
            const handleNodeClickInternal = (e, nodeId) => {
                if (e.ctrlKey || e.metaKey || draggingNode) return;
                if (visitedNodes.has(nodeId)) {
                    onNodeClick(nodeId);
                }
            };

            const handleMouseMove = useCallback((e) => {
                if (!draggingNode) return;
                const svg = svgRef.current;
                if (!svg) return;
                const pt = svg.createSVGPoint();
                pt.x = e.clientX; pt.y = e.clientY;
                const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
                const newX = Math.max(nodeWidth/2, svgP.x - dragOffset.x);
                const newY = Math.max(nodeHeight/2, svgP.y - dragOffset.y);
                setNodePositions(prev => ({ ...prev, [draggingNode]: { x: newX, y: newY } }));
                setSvgSize(prev => ({ width: Math.max(prev.width, newX + nodeWidth + padding), height: Math.max(prev.height, newY + nodeHeight + padding) }));
            }, [draggingNode, dragOffset, nodeWidth, nodeHeight, padding]);

            const handleMouseUp = useCallback(() => {
                setDraggingNode(null);
            }, []);

            useEffect(() => {
                if (draggingNode) {
                    window.addEventListener('mousemove', handleMouseMove);
                    window.addEventListener('mouseup', handleMouseUp);
                    return () => { window.removeEventListener('mousemove', handleMouseMove); window.removeEventListener('mouseup', handleMouseUp); };
                }
            }, [draggingNode, handleMouseMove, handleMouseUp]);

            const handleResetLayout = () => {
                const autoLayout = calculateAutoPositions(nodes, scenarioData.startNode);
                setNodePositions(autoLayout.positions);
                const allX = Object.values(autoLayout.positions).map(p => p.x);
                const allY = Object.values(autoLayout.positions).map(p => p.y);
                setSvgSize({ width: Math.max(...allX, 400) + nodeWidth + padding, height: Math.max(...allY, 300) + nodeHeight + padding });
            };

            const connections = [];
            Object.entries(nodes).forEach(([nodeId, node]) => {
                if (node.choices && nodePositions[nodeId]) {
                    node.choices.forEach((choice, idx) => {
                        if (choice.next && nodePositions[choice.next]) {
                            connections.push({ from: nodePositions[nodeId], to: nodePositions[choice.next], fromId: nodeId, toId: choice.next, visited: visitedNodes.has(nodeId) && visitedNodes.has(choice.next), key: `${nodeId}-${choice.next}-${idx}` });
                        }
                    });
                }
            });

            const getNodeLabel = (nodeId) => {
                const node = nodes[nodeId];
                if (!node) return nodeId;
                const content = getText(node.content);
                const match = content.match(/^#\s+(.+)$/m);
                if (match) { const title = match[1].replace(/\*\*/g, ''); return title.length > 15 ? title.slice(0, 12) + '...' : title; }
                return nodeId;
            };

            const getConnectionPath = (conn) => {
                const x1 = conn.from.x, y1 = conn.from.y + nodeHeight / 2, x2 = conn.to.x, y2 = conn.to.y - nodeHeight / 2;
                const isBackward = conn.to.y < conn.from.y;
                const isSameLevel = Math.abs(conn.to.y - conn.from.y) < nodeHeight;
                if (!isBackward && !isSameLevel) return { path: `M ${x1} ${y1} L ${x2} ${y2}`, type: 'line', x1, y1, x2, y2 };
                const midX = (x1 + x2) / 2, midY = (y1 + y2) / 2;
                const curveOffset = isBackward ? Math.max(80, Math.abs(conn.from.y - conn.to.y) * 0.3 + 60) : 50;
                const curveDirection = x1 <= x2 ? 1 : -1;
                const controlX = midX + (curveOffset * curveDirection * (isBackward ? 1.5 : 1));
                const controlY = isBackward ? Math.min(y1, y2) - 30 : midY;
                return { path: `M ${x1} ${y1} Q ${controlX} ${controlY} ${x2} ${y2}`, type: 'bezier', x1, y1, x2, y2, cx: controlX, cy: controlY };
            };

            const getArrowPosition = (pathData) => {
                if (pathData.type === 'line') {
                    const mx = (pathData.x1 + pathData.x2) / 2, my = (pathData.y1 + pathData.y2) / 2;
                    return { x: mx, y: my, angle: Math.atan2(pathData.y2 - pathData.y1, pathData.x2 - pathData.x1) * 180 / Math.PI };
                }
                const t = 0.5;
                const mx = (1-t)*(1-t)*pathData.x1 + 2*(1-t)*t*pathData.cx + t*t*pathData.x2;
                const my = (1-t)*(1-t)*pathData.y1 + 2*(1-t)*t*pathData.cy + t*t*pathData.y2;
                const tx = 2*(1-t)*(pathData.cx - pathData.x1) + 2*t*(pathData.x2 - pathData.cx);
                const ty = 2*(1-t)*(pathData.cy - pathData.y1) + 2*t*(pathData.y2 - pathData.cy);
                return { x: mx, y: my, angle: Math.atan2(ty, tx) * 180 / Math.PI };
            };

            return (
                <div className="map-overlay">
                    <div className="map-header">
                        <h2>{translations.mapOf} {scenarioData.meta?.title || 'Scenario'}</h2>
                        <div className="map-toolbar">
                            <button className="btn-secondary" onClick={handleResetLayout} title="Reset to automatic layout">‚Üª Auto Layout</button>
                            <button className="close-button" onClick={onClose}>X</button>
                        </div>
                    </div>
                    <div className="map-content">
                        <svg ref={svgRef} width={svgSize.width} height={svgSize.height} style={{ display: 'block', margin: 'auto', cursor: draggingNode ? 'grabbing' : 'default' }}>
                            {connections.map((conn) => {
                                const pathData = getConnectionPath(conn);
                                const arrowPos = getArrowPosition(pathData);
                                const color = conn.visited ? 'var(--map-line-visited)' : 'var(--map-line-unvisited)';
                                return (
                                    <g key={conn.key}>
                                        <path d={pathData.path} fill="none" stroke={color} strokeWidth={2} />
                                        <polygon points="-8,-5 8,0 -8,5" fill={color} transform={`translate(${arrowPos.x}, ${arrowPos.y}) rotate(${arrowPos.angle})`} />
                                    </g>
                                );
                            })}
                            {Object.entries(nodePositions).map(([nodeId, pos]) => {
                                if (!nodes[nodeId]) return null;
                                const isVisited = visitedNodes.has(nodeId);
                                const isCurrent = nodeId === currentNode;
                                const isDragging = draggingNode === nodeId;
                                let fill, stroke, textFill;
                                if (isCurrent) { fill = 'var(--map-node-current)'; stroke = 'var(--map-node-current)'; textFill = 'var(--map-node-current-text)'; }
                                else if (isVisited) { fill = 'var(--map-node-visited)'; stroke = 'var(--map-node-visited)'; textFill = 'var(--map-node-visited-text)'; }
                                else { fill = 'var(--map-node-unvisited)'; stroke = 'var(--map-node-unvisited-border)'; textFill = 'var(--map-node-unvisited-text)'; }
                                return (
                                    <g key={nodeId} 
                                       className={`tree-node ${isVisited ? 'visited' : 'not-visited'} ${isCurrent ? 'current' : ''} ${isDragging ? 'dragging' : ''}`}
                                       style={{ cursor: isDragging ? 'grabbing' : (isVisited ? 'pointer' : 'default') }}
                                       onMouseDown={(e) => handleMouseDown(e, nodeId)}
                                       onClick={(e) => handleNodeClickInternal(e, nodeId)}>
                                        <rect x={pos.x - nodeWidth/2 + 10} y={pos.y - nodeHeight/2} width={nodeWidth - 20} height={nodeHeight} rx={8} fill={fill} stroke={stroke} strokeWidth={2} style={{ filter: isDragging ? 'drop-shadow(0 4px 6px rgba(0,0,0,0.2))' : 'none' }} />
                                        <text x={pos.x} y={pos.y + 4} textAnchor="middle" dominantBaseline="middle" fill={textFill} fontSize="11" fontWeight="500" style={{ pointerEvents: 'none', userSelect: 'none' }}>{getNodeLabel(nodeId)}</text>
                                    </g>
                                );
                            })}
                        </svg>
                    </div>
                    <div className="map-footer">üí° Click visited nodes to navigate ‚Ä¢ CTRL+drag to reposition</div>
                </div>
            );
        };

        const ChoiceMap = () => {
            const [scenarioData, setScenarioData] = useState(null);
            const [theme, setTheme] = useState(null);
            const [currentNode, setCurrentNode] = useState(null);
            const [visitedNodes, setVisitedNodes] = useState(new Set());
            const [history, setHistory] = useState([]);
            const [showMap, setShowMap] = useState(false);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [showCredits, setShowCredits] = useState(true);

            useEffect(() => {
                const loadAll = async () => {
                    try {
                        const defaultsRes = await fetch('defaults.json?v=' + Date.now());
                        if (defaultsRes.ok) {
                            const defaults = await defaultsRes.json();
                            if (defaults.fonts) fontOptions = defaults.fonts;
                            if (defaults.theme) defaultTheme = defaults.theme;
                            if (defaults.layout) layoutConfig = { ...layoutConfig, ...defaults.layout };
                        }
                        const configRes = await fetch('config.json?v=' + Date.now());
                        if (!configRes.ok) throw new Error('config.json not found');
                        const config = await configRes.json();
                        if (config.showCredits === false) setShowCredits(false);
                        const scenarioFile = config.scenario || 'scenario.json';
                        const themeFile = config.theme || 'theme.json';
                        const [scenarioRes, themeRes] = await Promise.all([fetch(scenarioFile + '?v=' + Date.now()), fetch(themeFile + '?v=' + Date.now())]);
                        if (!scenarioRes.ok) throw new Error(`Scenario file not found: ${scenarioFile}`);
                        const scenario = await scenarioRes.json();
                        const themeData = themeRes.ok ? await themeRes.json() : {};
                        applyTheme(themeData);
                        setScenarioData(scenario);
                        setTheme(themeData);
                        setCurrentNode(scenario.startNode);
                        setVisitedNodes(new Set([scenario.startNode]));
                        setHistory([scenario.startNode]);
                        setLoading(false);
                    } catch (err) { setError(err.message); setLoading(false); }
                };
                loadAll();
            }, []);

            const translations = { step: 'Step', restart: 'Start Over', endOfPath: 'End of this path', resources: 'Resources', viewMap: 'View Map', mapOf: 'Map of', back: 'Back', download: 'Download', openLink: 'Open', watchVideo: 'Watch', ...scenarioData?.translations };
            const handleChoice = (nextNode) => { setVisitedNodes(prev => new Set([...prev, nextNode])); setHistory(prev => [...prev, nextNode]); setCurrentNode(nextNode); };
            const handleBack = () => { if (history.length > 1) { const newHistory = history.slice(0, -1); setHistory(newHistory); setCurrentNode(newHistory[newHistory.length - 1]); } };
            const handleRestart = () => { setCurrentNode(scenarioData.startNode); setVisitedNodes(new Set([scenarioData.startNode])); setHistory([scenarioData.startNode]); };
            const handleMapNodeClick = (nodeId) => { setCurrentNode(nodeId); setHistory(prev => [...prev, nodeId]); setShowMap(false); };

            if (loading) return <div className="loading">Loading...</div>;
            if (error) return <div className="error"><span>Error: {error}</span></div>;
            if (!scenarioData || !currentNode) return <div className="error"><span>No scenario data</span></div>;

            const node = scenarioData.nodes[currentNode];
            if (!node) return <div className="error"><span>Node not found: {currentNode}</span></div>;

            const content = getText(node.content);
            const choices = node.choices || [];
            const resources = node.resources || [];
            const isTerminal = choices.length === 0;
            const currentIndex = history.indexOf(currentNode) + 1;

            const getResourceIcon = (type) => {
                if (type === 'video') return '‚ñ∂Ô∏è';
                if (type === 'download') return 'üì•';
                return 'üîó';
            };
            const getResourceLabel = (type) => {
                if (type === 'video') return translations.watchVideo;
                if (type === 'download') return translations.download;
                return translations.openLink;
            };

            return (
                <div className="slide-container">
                    <div className="header-bar">
                        <div className="brand-header">
                            {showCredits && <span className="brand-name"><a href="https://ai-know.pro" target="_blank" rel="noopener noreferrer">ChoiceMap</a></span>}
                        </div>
                        <div className="scenario-title">{scenarioData.meta?.title}</div>
                    </div>
                    {history.length > 1 && (
                        <button className="back-button" onClick={handleBack}>
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
                            {translations.back}
                        </button>
                    )}
                    <div className="slide-content">
                        {isTerminal && <span className="terminal-badge">{translations.endOfPath}</span>}
                        <MarkdownContent content={content} />
                        {choices.length > 0 && (
                            <div className="choices-container">
                                {choices.map((choice, index) => {
                                    const isVisited = visitedNodes.has(choice.next);
                                    const allExplored = (scenarioData.nodes[choice.next]?.choices || []).every(c => visitedNodes.has(c.next));
                                    return (
                                        <button key={index} className={`choice-button ${isVisited ? (allExplored ? 'explored' : 'visited') : ''}`} onClick={() => handleChoice(choice.next)}>
                                            {getText(choice.text)}
                                        </button>
                                    );
                                })}
                            </div>
                        )}
                        {isTerminal && <button className="restart-button" onClick={handleRestart}>{translations.restart}</button>}
                        {resources.length > 0 && (
                            <div className="resources-section">
                                <div className="resources-title">{translations.resources}</div>
                                {resources.map((res, i) => (
                                    <a key={i} href={res.url} target="_blank" rel="noopener noreferrer" className="resource-link" download={res.type === 'download' ? true : undefined}>
                                        {getResourceIcon(res.type)} {getText(res.label) || getResourceLabel(res.type)}
                                    </a>
                                ))}
                            </div>
                        )}
                    </div>
                    <div className="progress-indicator">{translations.step} {currentIndex}</div>
                    <button className="map-button" onClick={() => setShowMap(true)}>üó∫Ô∏è {translations.viewMap}</button>
                    {showMap && <TreeMap scenarioData={scenarioData} nodes={scenarioData.nodes} visitedNodes={visitedNodes} currentNode={currentNode} onNodeClick={handleMapNodeClick} onClose={() => setShowMap(false)} translations={translations} />}
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<ChoiceMap />);
    </script>
</body>
</html>
